<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeetCode题目解答,Java实现(Hard部分) | Jeck_Zhang</title>
  <meta name="author" content="Jeck Zhang">
  
  <meta name="description" content="zxc&#39;s blog | java | ruby | perl | linux">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="LeetCode题目解答,Java实现(Hard部分)"/>
  <meta property="og:site_name" content="Jeck_Zhang"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link type="image/x-icon" href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Jeck_Zhang" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="/js/jquery.min.js"></script>
  
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45019001-1', 'topdna.org');
  ga('send', 'pageview');

</script>


</head>


<body>
  <!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://storage.ie6countdown.com/assets/100/images/banners/warning_bar_0027_Simplified Chinese.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Jeck_Zhang</a></h1>
  <h2><a href="/">Write the Code. Change the World.</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="http://weibo.com/zxc337">weibo</a></li>
    
      <li><a href="/2014/10/01/aboutMe/">关于</a></li>
    
      <li><a href="/tags/随感/">随感</a></li>
    
      <li><a href="/tags/技术/">技术</a></li>
    
      <li><a href="/tags/理财/">理财</a></li>
    
      <li><a href="/tags/生活/">生活</a></li>
    
      <li><a href="/archives">归档</a></li>
    
    <li><a href="/atom.xml">RSS</a></li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2012-03-11T03:15:44.000Z"><a href="/2012/03/11/leetcode/">3月 11 2012</a></time>
      
      
  
    <h1 class="title">LeetCode题目解答,Java实现(Hard部分)</h1>
  

    </header>
    <div class="entry">
      
        <p>以下是LeetCode题目解答的最后一部分：Hard部分,以下代码均用java实现。</p>
<table>
<thead>
<tr>
<th><a href="https://leetcode.com/problemset/" target="_blank" rel="external">Title</a></th>
<th style="text-align:center"><a href="https://leetcode.com/problemset/" target="_blank" rel="external">Acceptance</a></th>
<th style="text-align:center"><a href="https://leetcode.com/problemset/" target="_blank" rel="external">Difficulty</a></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#text-justification">Text Justification</a></td>
<td style="text-align:center">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14.0%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#search-in-rotated-sorted-array">Search in Rotated Sorted Array</a></td>
<td style="text-align:center">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28.6%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#binary-tree-maximum-path-sum">Binary Tree Maximum Path Sum</a></td>
<td style="text-align:center">20.2%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#reverse-nodes-in-k-group">Reverse Nodes in k-Group</a></td>
<td style="text-align:center">24.9%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#binary-tree-postorder-traversal">Binary Tree Postorder Traversal</a></td>
<td style="text-align:center">31.0%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#candy">Candy</a></td>
<td style="text-align:center">19.3%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#edit-distance">Edit Distance</a></td>
<td style="text-align:center">25.5%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#recover-binary-search-tree">Recover Binary Search Tree</a></td>
<td style="text-align:center">23.7%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#populating-next-right-pointers-in-each-node-ii">Populating Next Right Pointers in Each Node II</a></td>
<td style="text-align:center">30.7%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#permutations-ii">Permutations II</a></td>
<td style="text-align:center">25.0%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#best-time-to-buy-and-sell-stock-iii">Best Time to Buy and Sell Stock III</a></td>
<td style="text-align:center">22.4%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#palindrome-partitioning-ii">Palindrome Partitioning II</a></td>
<td style="text-align:center">18.3%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#n-queens-ii">N-Queens II</a></td>
<td style="text-align:center">33.9%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#substring-with-concatenation-of-all-words">Substring with Concatenation of All Words</a></td>
<td style="text-align:center">18.1%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#sudoku-solver">Sudoku Solver</a></td>
<td style="text-align:center">20.9%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#n-queens">N-Queens</a></td>
<td style="text-align:center">25.9%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#minimum-window-substring">Minimum Window Substring</a></td>
<td style="text-align:center">18.1%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#merge-k-sorted-lists">Merge k Sorted Lists</a></td>
<td style="text-align:center">21.2%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#merge-intervals">Merge Intervals</a></td>
<td style="text-align:center">20.9%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#scramble-string">Scramble String</a></td>
<td style="text-align:center">22.8%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#trapping-rain-water">Trapping Rain Water</a></td>
<td style="text-align:center">28.9%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#median-of-two-sorted-arrays">Median of Two Sorted Arrays</a></td>
<td style="text-align:center">17.6%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#maximal-rectangle">Maximal Rectangle</a></td>
<td style="text-align:center">21.5%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#max-points-on-a-line">Max Points on a Line</a></td>
<td style="text-align:center">11.2%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#lru-cache">LRU Cache</a></td>
<td style="text-align:center">14.1%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#longest-valid-parentheses">Longest Valid Parentheses</a></td>
<td style="text-align:center">19.7%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#longest-consecutive-sequence">Longest Consecutive Sequence</a></td>
<td style="text-align:center">28.2%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#copy-list-with-random-pointer">Copy List with Random Pointer</a></td>
<td style="text-align:center">23.5%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#largest-rectangle-in-histogram">Largest Rectangle in Histogram</a></td>
<td style="text-align:center">21.5%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#jump-game-ii">Jump Game II</a></td>
<td style="text-align:center">24.7%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#interleaving-string">Interleaving String</a></td>
<td style="text-align:center">19.5%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#insert-interval">Insert Interval</a></td>
<td style="text-align:center">20.7%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#wildcard-matching">Wildcard Matching</a></td>
<td style="text-align:center">14.3%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#distinct-subsequences">Distinct Subsequences</a></td>
<td style="text-align:center">25.0%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#word-break-ii">Word Break II</a></td>
<td style="text-align:center">16.6%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#first-missing-positive">First Missing Positive</a></td>
<td style="text-align:center">22.6%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#word-ladder-ii">Word Ladder II</a></td>
<td style="text-align:center">11.5%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#find-minimum-in-rotated-sorted-array-ii">Find Minimum in Rotated Sorted Array II</a></td>
<td style="text-align:center">27.9%</td>
<td style="text-align:center">Hard</td>
</tr>
<tr>
<td><a href="#regular-expression-matching">Regular Expression Matching</a></td>
<td style="text-align:center">20.2%</td>
<td style="text-align:center">Hard</td>
</tr>
</tbody>
</table>
<h3 id="Text_Justification"><span id="text-justification" style="color: #ff0000;">Text Justification</span></h3>
<p>【题目】Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.<br>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly Lcharacters.<br>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.<br>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<p>For example,<br>words: [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”]<br>L: 16.</p>
<p>Return the formatted lines as:<br>[<br>   “This    is    an”,<br>   “example  of text”,<br>   “justification.  “<br>]<br>Note: Each word is guaranteed not to exceed L in length.</p>
<p>【解答】主要要把题意理解透彻，几个corner case的理解，包括最末一行的处理，还有面对空字符串的处理。遍历的时候，i从0遍历到words.length，在i==words.length的时候处理最末一行的情况。感觉这个题目其实没有太多技巧性，就是需要细心和耐心，把逻辑想清楚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title">fullJustify</span>(String[] words, <span class="keyword">int</span> L) {</div><div class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line"> </div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">int</span> lenSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= words.length; i++) {</div><div class="line">            String cur;</div><div class="line">            <span class="keyword">if</span> (i == words.length)</div><div class="line">                cur = <span class="string">""</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                cur = words[i];</div><div class="line"> </div><div class="line">            <span class="keyword">if</span> (lenSum + cur.length() + list.size() &gt; L || i == words.length) {</div><div class="line">                <span class="keyword">int</span> slots = list.size() - <span class="number">1</span>;</div><div class="line"> </div><div class="line">                <span class="keyword">int</span> basicSpaces = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (slots != <span class="number">0</span>)</div><div class="line">                    basicSpaces = (L - lenSum) / slots;</div><div class="line">                <span class="keyword">if</span> (i==words.length)</div><div class="line">                    basicSpaces = <span class="number">1</span>;</div><div class="line"> </div><div class="line">                <span class="keyword">int</span> moreSpaces = L - lenSum;</div><div class="line">                <span class="keyword">if</span> (slots != <span class="number">0</span> && basicSpaces &gt; <span class="number">0</span>)</div><div class="line">                    moreSpaces = (L - lenSum) % slots;</div><div class="line">                <span class="keyword">if</span> (i==words.length)</div><div class="line">                    moreSpaces = L - lenSum - slots;</div><div class="line"> </div><div class="line">                <span class="comment">// append</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size(); j++) {</div><div class="line">                    <span class="keyword">if</span> (j != <span class="number">0</span>) {</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; basicSpaces; k++)</div><div class="line">                            sb.append(<span class="string">' '</span>);</div><div class="line"> </div><div class="line">                        <span class="keyword">if</span> (moreSpaces &gt; <span class="number">0</span> && i != words.length) {</div><div class="line">                            sb.append(<span class="string">' '</span>);</div><div class="line">                            moreSpaces--;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                    sb.append(list.get(j));</div><div class="line">                }</div><div class="line"> </div><div class="line">                <span class="comment">// trailing spaces</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; moreSpaces; k++) {</div><div class="line">                    sb.append(<span class="string">' '</span>);</div><div class="line">                }</div><div class="line"> </div><div class="line">                list.clear();</div><div class="line">                lenSum = <span class="number">0</span>;</div><div class="line"> </div><div class="line">                result.add(sb.toString());</div><div class="line">                sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">            }</div><div class="line"> </div><div class="line">            list.add(cur);</div><div class="line">            lenSum += cur.length();</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Search_in_Rotated_Sorted_Array"><span id="search-in-rotated-sorted-array" style="color: #ff0000;">Search in Rotated Sorted Array</span></h3>
<p>【题目】Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array. </p>
<p>【解答】不知道为什么这道题归为Hard，其实思路还是很容易找到的。如果是一个单纯的升序排列的数组，那就是二分法查找，现在这个数组可能被rotate了，那么还是借由二分法，只不过在找到中间的数了之后，需要比较中间数和最右数（或者最左数），有这样的结论：</p>
<ol>
<li>如果中间数大于最右数，那么最大最小数的分界点在右半支，而左半支严格单调递增，在这种情况下通过比较左半支的首尾两个数，判断目标数在不在左半支内，如果不在，就一定在右半支内。</li>
<li>如果中间数小于最右数，那么最大最小数的分界点在左半支，而右半支严格单调递增，在这种情况下通过比较右半支的首尾两个数，判断目标数在不在右半支内，如果不在，就一定在左半支内。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span>(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target) {</div><div class="line">        <span class="keyword">return</span> search(A, target, <span class="number">0</span>, A.length-<span class="number">1</span>);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span>(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end) {</div><div class="line">        <span class="keyword">if</span> (start&gt;end)</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> mid = (end+start)/<span class="number">2</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (target==A[mid])</div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (A[end]&gt;=A[mid]) { <span class="comment">// the right part is increasing</span></div><div class="line">            <span class="keyword">if</span> (target&gt;A[end] || targetA[mid]) {</div><div class="line">                <span class="keyword">return</span> search(A, target, mid+<span class="number">1</span>, end);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">return</span> search(A, target, start, mid-<span class="number">1</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Binary_Tree_Maximum_Path_Sum"><span id="binary-tree-maximum-path-sum" style="color: #ff0000;">Binary Tree Maximum Path Sum</span></h3>
<p>【题目】Given a binary tree, find the maximum path sum.</p>
<p>The path may start and end at any node in the tree.</p>
<p>For example:<br>Given the below binary tree,</p>
<pre><code>   1
  / <span class="command">\
</span> 2   3
</code></pre><p>Return 6.</p>
<p>【解答】定义一个maxSinglePath方法，用来返回以root为根的树从根开始存在的最大单向路径（根到某叶子或者根到某分支节点）。再定义一个pathSum方法，用来返回以root为根时，该树的最大path sum，在该方法内，调用maxSinglePath方法分别获取左子树和右子树的最大单向路径，二者之和再加上当前节点的值为包含当前root的最大path sum，再递归求出左子树的最大path sum和右子树的最大path sum，三者取最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span>(TreeNode root) {</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==root)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">         </div><div class="line">        Map&lt;TreeNode, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">return</span> pathSum(root, map);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pathSum</span>(TreeNode root, Map&lt;TreeNode, Integer&gt; map) {</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) {</div><div class="line">            left = maxSinglePath(root.left, map);</div><div class="line">            <span class="keyword">if</span> (left&lt;<span class="number">0</span>)</div><div class="line">                left = <span class="number">0</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) {</div><div class="line">            right = maxSinglePath(root.right, map);</div><div class="line">            <span class="keyword">if</span> (right&lt;<span class="number">0</span>)</div><div class="line">                right = <span class="number">0</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> current = left + right + root.val;</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">int</span> l = pathSum(root.left, map);</div><div class="line">            <span class="keyword">if</span> (l&gt;current)</div><div class="line">                current = l;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">int</span> r = pathSum(root.right, map);</div><div class="line">            <span class="keyword">if</span> (r&gt;current)</div><div class="line">                current = r;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> current;</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxSinglePath</span>(TreeNode root, Map&lt;TreeNode, Integer&gt; map) {</div><div class="line">        <span class="keyword">if</span> (map.containsKey(root))</div><div class="line">            <span class="keyword">return</span> map.get(root);</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) {</div><div class="line">            left = maxSinglePath(root.left, map);</div><div class="line">            <span class="keyword">if</span> (left&lt;<span class="number">0</span>)</div><div class="line">                left = <span class="number">0</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) {</div><div class="line">            right = maxSinglePath(root.right, map);</div><div class="line">            <span class="keyword">if</span> (right&lt;<span class="number">0</span>)</div><div class="line">                right = <span class="number">0</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> maxVal = Math.max(left, right) + root.val;</div><div class="line">        map.put(root, maxVal);</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> maxVal;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Reverse_Nodes_in_k-Group"><span id="reverse-nodes-in-k-group" style="color: #ff0000;">Reverse Nodes in k-Group</span></h3>
<p>【题目】Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.<br>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.<br>You may not alter the values in the nodes, only nodes itself may be changed.<br>Only constant memory is allowed.</p>
<p>For example,<br>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5<br>【解答】引入一个伪节点作为头，可以免去对head的特殊处理。基本思路是：一个快指针，一个慢指针，平时慢指针不动，快指针往前跑，在二者间距达到k时，令start=slow.next，end=fast，对于[start,end]这一段区间的节点指向反向，反向后令slow.next=end，fast=start。题目不难，小心一点便是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span>(ListNode head, <span class="keyword">int</span> k) {</div><div class="line">        ListNode fake = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        fake.next = head;</div><div class="line">         </div><div class="line">        ListNode fast = fake;</div><div class="line">        ListNode slow = fake;</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (count==k) {</div><div class="line">                ListNode start = slow.next;</div><div class="line">                ListNode end = fast;</div><div class="line">                fast = end.next;</div><div class="line">                 </div><div class="line">                ListNode n = start;</div><div class="line">                ListNode next = n.next;</div><div class="line">                <span class="keyword">while</span> (n!=end) {</div><div class="line">                    ListNode temp = next.next;</div><div class="line">                    next.next = n;</div><div class="line">                     </div><div class="line">                    n = next;</div><div class="line">                    next = temp;</div><div class="line">                }</div><div class="line">                 </div><div class="line">                slow.next = end;</div><div class="line">                start.next = fast;</div><div class="line">                 </div><div class="line">                slow = start;</div><div class="line">                fast = slow;</div><div class="line">                 </div><div class="line">                count=<span class="number">0</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                fast = fast.next;</div><div class="line">                count++;</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> fake.next;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Binary_Tree_Postorder_Traversal"><span id="binary-tree-postorder-traversal" style="color: #ff0000;">Binary Tree Postorder Traversal</span></h3>
<p>【题目】Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},</p>
<pre><code>       1
        <span class="command">\
</span>           2
        /
       3
</code></pre><p>return [3,2,1].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?<br>解答】如果是递归遍历，没有任何难度，也不可能放到Hard级别里面来。用非递归方式，需要一个辅助栈，用来存放节点pop出来的当前状态。具体说：</p>
<ul>
<li>当前节点不为空，就先遍历左子树，同时当前节点入栈，状态栈入true；</li>
<li>当前节点为空，退栈，如果状态为true，就遍历右子树，状态栈顶变为false；</li>
<li>当前节点为空，退栈，如果状态为false，就遍历退栈节点，相应状态元素退栈。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span>(TreeNode root) {</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        Stack&lt;Boolean&gt; status = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">         </div><div class="line">        TreeNode node = root;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty() || node!=<span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span>!=node) {</div><div class="line">                stack.push(node);</div><div class="line">                status.push(<span class="keyword">true</span>);</div><div class="line">                 </div><div class="line">                node = node.left;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                node = stack.peek();</div><div class="line">                <span class="keyword">boolean</span> flag = status.pop();</div><div class="line">                 </div><div class="line">                <span class="keyword">if</span> (flag) {</div><div class="line">                    node = node.right;</div><div class="line">                    status.push(<span class="keyword">false</span>);</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    result.add(node.val);</div><div class="line">                    stack.pop();</div><div class="line">                    node = <span class="keyword">null</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Candy"><span id="candy" style="color: #ff0000;">Candy</span></h3>
<p>【题目】There are N children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<p>Each child must have at least one candy.<br>Children with a higher rating get more candies than their neighbors.<br>What is the minimum candies you must give?</p>
<p>【解答】最开始我选择的做法是像分析函数曲线一样找拐点，如果知道这条曲线的拐点，比如极大值，那么极大值左侧是递增的，极大值右侧是递减的；极小值左侧递减，右侧递增。这里特别麻烦的地方在于，极小值取值是显然为1，但极大值的取值取决于极大值两侧单调曲线的长度，要取长的那一侧的最大值。</p>
<p>比如ratings=[1, 2, 3, 4, 5, 4, 1]，其中ratings[4]就是一个极大值，但是取值candies[4]取决于ratings[4]左右两侧单调曲线的长度，左侧比右侧长，因此要根据左侧来计数取值，在这里candies[4]就取5（如果根据右侧来取值就是3，那就错了）。还需要考虑一些特殊的case，比如极大、极小值出现在首尾，这种情况下是只有右侧或者只有左侧单调曲线的。因此这个办法的代码写起来比较复杂。</p>
<p>下面这个办法我也是参考了别人的解法的，两遍遍历，一遍正向，一遍逆向，思路非常清晰：</p>
<p>正向遍历的时候，如果发现递增序列，就放置一个从1开始依次递增的数，但是，存在这样错误的情况：如果是递减序列的情况呢，这里全放置了1；<br>那么这个问题就需要通过逆向遍历来消除。<br>那么这个办法对于我之前办法所说的那个不易处理的问题，通过逆向遍历中的一个关系为且的子判断条件candies[i]&lt;=candies[i+1]给巧妙的规避掉了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span>(<span class="keyword">int</span>[] ratings) {</div><div class="line">        <span class="keyword">if</span> (ratings == <span class="keyword">null</span> || ratings.length == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (ratings.length == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</div><div class="line">        candies[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line"> </div><div class="line">        <span class="comment">// forward</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.length; i++) {</div><div class="line">            <span class="comment">// rating: asc</span></div><div class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>])</div><div class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                candies[i] = <span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// backward</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</div><div class="line">            <span class="comment">// rating: desc && candy: asc</span></div><div class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] && candies[i] &lt;= candies[i + <span class="number">1</span>])</div><div class="line">                candies[i] = candies[i + <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ratings.length; i++)</div><div class="line">            total += candies[i];</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> total;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Edit_Distance"><span id="edit-distance" style="color: #ff0000;">Edit Distance</span></h3>
<p>【题目】Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
<p>【解答】遇到这种求两个东西之间距离的，要么回溯法，要么动态规划。这里就是动态规划，这个题目还是很有代表性的。建立一个dist二维数组，注意行、列的长度要分别比word1和word2的长度多1，dist[i][j]用来表示word1.substring(0,i)到word2.substring(0,j)的距离。因此dist[i][j]在i==0的时候为j，在j==0的时候为i。其余的情况，根据insert、delete和replace三种可能性分类讨论，取三种情况的最小距离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span>(String word1, String word2) {</div><div class="line">        Integer[][] dist = <span class="keyword">new</span> Integer[word1.length()+<span class="number">1</span>][word2.length()+<span class="number">1</span>];</div><div class="line">        <span class="keyword">return</span> min(word1, word2, word1.length(), word2.length(), dist);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span>(String w1, String w2, <span class="keyword">int</span> i, <span class="keyword">int</span> j, Integer[][] dist) {</div><div class="line">        <span class="keyword">if</span> (dist[i][j]!=<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> dist[i][j];</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>) {</div><div class="line">            dist[i][j] = j;</div><div class="line">            <span class="keyword">return</span> j;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>) {</div><div class="line">            dist[i][j] = i;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">char</span> ci = w1.charAt(i-<span class="number">1</span>);</div><div class="line">        <span class="keyword">char</span> cj = w2.charAt(j-<span class="number">1</span>);</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (ci==cj) {</div><div class="line">            dist[i][j] = min(w1, w2, i-<span class="number">1</span>, j-<span class="number">1</span>, dist);</div><div class="line">            <span class="keyword">return</span> dist[i][j];</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> insert = min(w1, w2, i-<span class="number">1</span>, j, dist) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> replace = min(w1, w2, i-<span class="number">1</span>, j-<span class="number">1</span>, dist) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> delete = min(w1, w2, i, j-<span class="number">1</span>, dist) + <span class="number">1</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> result = Math.min(delete, Math.min(insert, replace));</div><div class="line">         </div><div class="line">        dist[i][j] = result;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Recover_Binary_Search_Tree"><span id="recover-binary-search-tree" style="color: #ff0000;">Recover Binary Search Tree</span></h3>
<p>【题目】Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Note:<br>A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>
<p>【解答】对于BST，对任一节点，满足左分支上面所有的节点都小于根节点，右分支上面所有的节点都大于根节点，而中序遍历能够保证形成正确的递增序列，因此遍历时能够保证当前节点的大小一定大于前一个节点的大小。这一点是做这道题的基础。</p>
<p>对于其中某两个节点被错误的swap了，这里有两种情况可供讨论：</p>
<p>两个错误节点是相邻的，比如：0,1,2,3,5,4,6，这种情况中序遍历的整个过程只能发现一次异常节点，在这里是4，这种情况，需要把异常节点和它前面那个节点调换，即4和5调换；<br>两个错误节点不相邻，比如：0,1,5,3,4,2,6，这种情况中序遍历的整个过程可以发现两次异常节点，在这里分别为3和2，这种情况下，需要把第一个异常节点的前面那个节点和第二个异常节点调换，即5和2。<br>掌握这两点规律以后问题就很好解了。下面的解法里面，en用于存储第一个异常节点，enLast表示第一个异常节点的前面那个节点。StopTraversalException的定义其实是可选的，用于在发现第二个异常节点之后直接交换错误值并返回，没必要再往后遍历了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">class StopTraversalException extends RuntimeException {</div><div class="line">    <span class="keyword">public</span> <span class="title">StopTraversalException</span>() {</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">private</span> TreeNode en = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> TreeNode enLast = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> TreeNode last = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</div><div class="line">     </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span>(TreeNode root) {</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==root)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">             </div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            traverse(root);</div><div class="line">        } <span class="keyword">catch</span> (StopTraversalException e) {</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        swap(en, enLast);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span>(TreeNode root) {</div><div class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>)</div><div class="line">            traverse(root.left);</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (last.val&gt;root.val) {</div><div class="line">            <span class="keyword">if</span> (en==<span class="keyword">null</span>) {</div><div class="line">                en = root;</div><div class="line">                enLast = last;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                swap(enLast, root);</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StopTraversalException();</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        last = root;</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>)</div><div class="line">            traverse(root.right);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(TreeNode n1, TreeNode n2) {</div><div class="line">        <span class="keyword">int</span> temp = n1.val;</div><div class="line">        n1.val = n2.val;</div><div class="line">        n2.val = temp;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Populating_Next_Right_Pointers_in_Each_Node_II"><span id="populating-next-right-pointers-in-each-node-ii" style="color: #ff0000;">Populating Next Right Pointers in Each Node II</span></h3>
<p>【题目】Follow up for problem “Populating Next Right Pointers in Each Node“.</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>For example,</p>
<p>Given the following binary tree,</p>
<pre><code>     1
   /  <span class="command">\
</span>  2    3
 / <span class="command">\ </span>   <span class="command">\
</span>4   5    7
</code></pre><p>After calling your function, the tree should look like:</p>
<pre><code>     <span class="number">1</span> <span class="subst">-&gt; </span><span class="built_in">NULL</span>
   <span class="subst">/</span>  <span class="subst">\</span>
  <span class="number">2</span> <span class="subst">-&gt; </span><span class="number">3</span> <span class="subst">-&gt; </span><span class="built_in">NULL</span>
 <span class="subst">/</span> <span class="subst">\</span>    <span class="subst">\</span>
<span class="number">4</span><span class="subst">-&gt; </span><span class="number">5</span> <span class="subst">-&gt; </span><span class="number">7</span> <span class="subst">-&gt; </span><span class="built_in">NULL</span>
</code></pre><p>【解答】看起来只是在《Populating Next Right Pointers in Each Node》基础上增加了一个节点可能为空的情况，但是难度其实增加不少。我把原有的递归改成这种从上到下一层一层循环执行的逻辑，我觉得是比较清晰的办法。对于每一层（level），引入一个fake节点来帮助掌控每一层的头部，按序构建next关联关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span>(TreeLinkNode root) {</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"> </div><div class="line">        TreeLinkNode level = root;</div><div class="line">        <span class="keyword">while</span> (level != <span class="keyword">null</span>) {</div><div class="line">            TreeLinkNode n = level;</div><div class="line">            TreeLinkNode fake = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);</div><div class="line">            TreeLinkNode child = fake;</div><div class="line"> </div><div class="line">            <span class="keyword">while</span> (n != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">if</span> (n.left != <span class="keyword">null</span>) {</div><div class="line">                    child.next = n.left;</div><div class="line">                    child = child.next;</div><div class="line">                }</div><div class="line"> </div><div class="line">                <span class="keyword">if</span> (n.right != <span class="keyword">null</span>) {</div><div class="line">                    child.next = n.right;</div><div class="line">                    child = child.next;</div><div class="line">                }</div><div class="line"> </div><div class="line">                n = n.next;</div><div class="line">            }</div><div class="line"> </div><div class="line">            child.next = <span class="keyword">null</span>;</div><div class="line">            level = fake.next;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Permutations_II"><span id="permutations-ii" style="color: #ff0000;">Permutations II</span></h3>
<p>【题目】Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br>[1,1,2] have the following unique permutations:<br>[1,1,2], [1,2,1], and [2,1,1].</p>
<p>【解答】大致的思路就是回溯法，但是这里需要注意去重的处理，如果这一点上思路选择不合适的话就会绕很大的圈子。先给num数组排序，那么对于任何重复数字的情况，例如num为1,2,2,3,4，其中2有重复，假设给这两个2分别标号：2-1和2-2，如果我可以保证最终输出的序列中，2的顺序也是一致的，即2-1一定出现在2-2之前，那么，就恰好去重了。</p>
<p>所以在下面的build方法里面的for循环中，第二个continue的判断条件，就用到了这样的逻辑——如果num[i]==num[i-1]且used[i-1]==false，这表示当有某个数重复出现时，这个序列先用到了后面的那个，这违背了重复数字保序性的要求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title">permuteUnique</span>(<span class="keyword">int</span>[] num) {</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; total = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (num==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> total;</div><div class="line">         </div><div class="line">        Arrays.sort(num);</div><div class="line">         </div><div class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[num.length];</div><div class="line">        build(num, used, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), total);</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> total;</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span> (<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; total) {</div><div class="line">        <span class="keyword">if</span> (list.size()==nums.length) {</div><div class="line">            total.add(list);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) {</div><div class="line">            <span class="keyword">if</span> (used[i])</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> && nums[i]==nums[i-<span class="number">1</span>] && !used[i-<span class="number">1</span>])</div><div class="line">                 <span class="keyword">continue</span>;</div><div class="line">             </div><div class="line">            used[i] = <span class="keyword">true</span>;</div><div class="line">            List&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;(list);</div><div class="line">            l.add(nums[i]);</div><div class="line">            build (nums, used, l, total);</div><div class="line">            used[i] = <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Best_Time_to_Buy_and_Sell_Stock_III"><span id="best-time-to-buy-and-sell-stock-iii" style="color: #ff0000;">Best Time to Buy and Sell Stock III</span></h3>
<p>【题目】Say you have an array for which the i<span style="box-sizing: border-box; position: relative; font-size: 11px; line-height: 0; vertical-align: baseline; top: -0.5em;">th</span> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>【解答】最开始我还是按照《Best Time to Buy and Sell Stock》的思路来解题：那个思路已经可以给出一段区间内的max profit，保留该方法，当前这道题相当于给出一个切分点i，在[0,i]和[i,prices.length)这两段区间内分别求max profit，取二者之和的最大值。但是在遇到比较长的case的时候超时了，所以引入二维数组来缓存计算过的数据，减少重复计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span>(<span class="keyword">int</span>[] prices) {</div><div class="line">        <span class="keyword">if</span> (prices.length&lt;=<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">         </div><div class="line">        mins = <span class="keyword">new</span> Integer[prices.length][prices.length];</div><div class="line">        maxs = <span class="keyword">new</span> Integer[prices.length][prices.length];</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.length; i++) {</div><div class="line">            <span class="keyword">int</span> left = maxProfit(prices, <span class="number">0</span>, i+<span class="number">1</span>);</div><div class="line">            <span class="keyword">int</span> right = maxProfit(prices, i, prices.length-i);</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (left+right&gt;max)</div><div class="line">                max = left+right;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> Integer[][] mins; <span class="comment">// first n days</span></div><div class="line">    <span class="keyword">private</span> Integer[][] maxs; <span class="comment">// last n days</span></div><div class="line"> </div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxProfit</span>(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> offset, <span class="keyword">int</span> len) {</div><div class="line">        <span class="keyword">if</span> (len&lt;=<span class="number">1</span>) {</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (mins[offset][<span class="number">0</span>]==<span class="keyword">null</span>)</div><div class="line">            mins[offset][<span class="number">0</span>] = prices[offset];</div><div class="line">        <span class="keyword">if</span> (maxs[offset+len-<span class="number">1</span>][offset+len-<span class="number">1</span>]==<span class="keyword">null</span>)</div><div class="line">            maxs[offset+len-<span class="number">1</span>][offset+len-<span class="number">1</span>] = prices[offset+len-<span class="number">1</span>];</div><div class="line">         </div><div class="line">        <span class="comment">// fill max prices, from right to left</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=len-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i–) {</div><div class="line">            <span class="keyword">if</span> (maxs[offset+len-<span class="number">1</span>][i]==<span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">if</span> (prices[offset+i]&gt;maxs[offset+len-<span class="number">1</span>][i+<span class="number">1</span>])</div><div class="line">                    maxs[offset+len-<span class="number">1</span>][i] = prices[offset+i];</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    maxs[offset+len-<span class="number">1</span>][i] = maxs[offset+len-<span class="number">1</span>][i+<span class="number">1</span>];</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="comment">// fill min prices, and calculate the biggest profit, from left to right</span></div><div class="line">        <span class="keyword">int</span> biggestProfit = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++) {</div><div class="line">            <span class="keyword">if</span> (mins[offset][i]==<span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">if</span> (prices[offset+i]&lt;mins[offset][i-<span class="number">1</span>])</div><div class="line">                    mins[offset][i] = prices[offset+i];</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    mins[offset][i] = mins[offset][i-<span class="number">1</span>];</div><div class="line">            }</div><div class="line">             </div><div class="line">            <span class="keyword">int</span> profit = maxs[offset+len-<span class="number">1</span>][i] – mins[offset][i];</div><div class="line">            <span class="keyword">if</span> (profit&gt;biggestProfit)</div><div class="line">                biggestProfit = profit;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> biggestProfit;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可是依然超时。这个思路毕竟也是换汤不换药，n平方的复杂度。造成这种局面的原因在于，</p>
<p> 外层循环那个n是来自于寻找前半段和后半段的切分点，这一层循环是无论如何都少不了的；<br> 里层循环那个n则是因为对每次前半段或者后半段自身，要再从后往前寻找最大价格，再从前往后遍历寻找最小价格，并且求出最大收益。<br>于是换个思路，改进球最大收益的过程，</p>
<p> 第一遍，从前往后循环对每个i的取值计算[0,i]的最大收益；<br> 第二遍，从后往前循环对每个i的取值计算[i,prices.length)的最大收益，并根据profits[i]的值相加球总收益，记录总收益的最大值。<br>于是复杂度变成n了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span>(<span class="keyword">int</span>[] prices) {</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == prices || prices.length &lt;= <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">int</span>[] profits = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</div><div class="line">        profits[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>], maxProfit = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) {</div><div class="line">            minPrice = Math.min(prices[i - <span class="number">1</span>], minPrice);</div><div class="line">            <span class="keyword">if</span> (maxProfit &lt; prices[i] - minPrice)</div><div class="line">                maxProfit = prices[i] - minPrice;</div><div class="line">            profits[i] = maxProfit;</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> maxPrice = prices[prices.length - <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> maxFinalProfit = profits[prices.length - <span class="number">1</span>];</div><div class="line">        maxProfit = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = prices.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</div><div class="line">            maxPrice = Math.max(maxPrice, prices[i + <span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span> (maxProfit &lt; maxPrice - prices[i])</div><div class="line">                maxProfit = maxPrice - prices[i];</div><div class="line">            <span class="keyword">if</span> (maxFinalProfit &lt; profits[i] + maxProfit)</div><div class="line">                maxFinalProfit = profits[i] + maxProfit;</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> maxFinalProfit;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Palindrome_Partitioning_II"><span id="palindrome-partitioning-ii" style="color: #ff0000;">Palindrome Partitioning II</span></h3>
<p>【题目】Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut.</p>
<p>【解答】借由《Palindrome Partitioning》的思路，对于给定的区间[start,end)，先判断是否是回文，如果不是，分别尝试在区间的各个位置截断，判断前半段和后半段是否都是回文。在对一些变态case超时以后，分两次加上了两个cache，isPalindromeCache和minCutCache，分别存储判断是否为回文的记录和计算cut次数的记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span>(String s) {</div><div class="line">        Boolean[][] isPalindromeCache = <span class="keyword">new</span> Boolean[s.length()][s.length()];</div><div class="line">        Integer[][] minCutCache = <span class="keyword">new</span> Integer[s.length()][s.length()];</div><div class="line">        <span class="keyword">if</span> (isPalindrome(s, <span class="number">0</span>, s.length(), cache))</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> minCut(s, <span class="number">0</span>, s.length(), isPalindromeCache, minCutCache);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minCut</span>(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Boolean[][] isPalindromeCache, Integer[][] minCutCache) {</div><div class="line">        <span class="keyword">if</span> (end-start&lt;=<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> min = end-start-<span class="number">1</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;end-start-<span class="number">1</span>; i++) {</div><div class="line">            <span class="keyword">if</span> (isPalindrome(s, start, start+i, isPalindromeCache)) {</div><div class="line">                <span class="keyword">if</span> (isPalindrome(s, start+i, end, isPalindromeCache))</div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                 </div><div class="line">                <span class="keyword">int</span> cut = minCut(s, start+i, end, isPalindromeCache)+<span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span> (cut&lt;min)</div><div class="line">                    min = cut;</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> min;</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span>(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Boolean[][] isPalindromeCache) {</div><div class="line">        <span class="keyword">if</span> (isPalindromeCache[start][end-<span class="number">1</span>]!=<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> isPalindromeCache[start][end-<span class="number">1</span>];</div><div class="line">             </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start, j=end-<span class="number">1</span>; j&gt;i; j--,i++) {</div><div class="line">            <span class="keyword">if</span> (s.charAt(i)!=s.charAt(j))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可即便如此，在遇到另外一些变态case的时候依然超时，比如这样一个case：514个a，加两个b，再加946个a。下面这个方法的思路也是从别处借鉴来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span>(String s) {</div><div class="line">        <span class="keyword">int</span> len = s.length();</div><div class="line"> </div><div class="line">        <span class="keyword">int</span>[] cut = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)</div><div class="line">            cut[i] = len - i;</div><div class="line"> </div><div class="line">        <span class="keyword">boolean</span>[][] isPalindrome = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</div><div class="line">         </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &&gt;t;= <span class="number">0</span>; i--) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) {</div><div class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)</div><div class="line">                        && (j - i &lt; <span class="number">2</span> || isPalindrome[i + <span class="number">1</span>][j - <span class="number">1</span>])) {</div><div class="line">                    isPalindrome[i][j] = <span class="keyword">true</span>;</div><div class="line">                     </div><div class="line">                    cut[i] = Math.min(cut[i], cut[j + <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> cut[<span class="number">0</span>] - <span class="number">1</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>逻辑上看简单多了，但是其实要更不容易想出来。用一个二维数组isPalindrome存放是否为回文的状态，两层循环嵌套，i从后往前，j从i往后遍历，如果s[i]==s[j]，并且前一个状态，即isPalindrome[i+1][j-1]为真，那么isPalindrome[i][j]也为真。一维数组cut用来存放需要切分的次数，初始为字符串区域的长度。</p>
<h3 id="N-Queens_II"><span id="n-queens-ii" style="color: #ff0000;">N-Queens II</span></h3>
<p>【题目】Follow up for N-Queens problem.<br><img src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png"><br>Now, instead outputting board configurations, return the total number of distinct solutions.</p>
<p>【解答】紧跟着N-Queens那道题，思路简直一模一样。不是很理解为啥弄两道差不多的题目。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">     </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span>(<span class="keyword">int</span> n) {</div><div class="line">        solveNQueens(<span class="number">0</span>, n, <span class="keyword">new</span> <span class="keyword">int</span>[n]);</div><div class="line">        <span class="keyword">return</span> total;</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solveNQueens</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">int</span>[] positions) {</div><div class="line">        <span class="keyword">if</span> (i == n) {</div><div class="line">            total++;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</div><div class="line">                positions[i] = j; <span class="comment">// row: i, col: j</span></div><div class="line">                <span class="keyword">if</span> (validate(i, positions)) {</div><div class="line">                    solveNQueens(i + <span class="number">1</span>, n, positions);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span>(<span class="keyword">int</span> maxRow, <span class="keyword">int</span>[] positions) {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRow; i++) {</div><div class="line">            <span class="keyword">if</span> (positions[i] == positions[maxRow] <span class="comment">// same column</span></div><div class="line">                    || Math.abs(positions[i] - positions[maxRow]) == maxRow - i) <span class="comment">// catercorner line</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Substring_with_Concatenation_of_All_Words"><span id="substring-with-concatenation-of-all-words" style="color: #ff0000;">Substring with Concatenation of All Words</span></h3>
<p>【题目】You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.</p>
<p>For example, given:<br>S: “barfoothefoobarman”<br>L: [“foo”, “bar”]</p>
<p>You should return the indices: [0,9].<br>(order does not matter).</p>
<p>【解答】先把L放到一个map里面去，key为单词，value为该单词在L中出现的次数。再遍历S，以S中每个字母为开头时，寻找是否存在满足题目要求的子串：发现单词匹配，就从dictCopy里面给这个单词出现的次数减一，如果一切匹配，就不会出现num==null或者num==0的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span>(String S, String[] L) {</div><div class="line">        Map&lt;String, Integer&gt; dict = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (String l : L) {</div><div class="line">            <span class="keyword">if</span> (!dict.containsKey(l)) {</div><div class="line">                dict.put(l, <span class="number">0</span>);</div><div class="line">            }</div><div class="line">             </div><div class="line">            dict.put(l, dict.get(l)+<span class="number">1</span>);</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> len = L[<span class="number">0</span>].length();</div><div class="line">        <span class="keyword">int</span> lenSum = len*L.length;</div><div class="line">         </div><div class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">         </div><div class="line">        traverseS : <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=S.length()-lenSum; i++) {</div><div class="line">            Map&lt;String, Integer&gt; dictCopy = <span class="keyword">new</span> HashMap&lt;&gt;(dict);</div><div class="line">             </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;i+lenSum; j=j+len) {</div><div class="line">                String s = S.substring(j, j+len);</div><div class="line">                Integer num = dictCopy.get(s);</div><div class="line">                <span class="keyword">if</span> (num==<span class="keyword">null</span> || num==<span class="number">0</span>)</div><div class="line">                    <span class="keyword">continue</span> traverseS;</div><div class="line">                num--;</div><div class="line">                dictCopy.put(s, num);</div><div class="line">            }</div><div class="line">             </div><div class="line">            list.add(i);</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Sudoku_Solver"><span id="sudoku-solver" style="color: #ff0000;">Sudoku Solver</span></h3>
<p>【题目】Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>Empty cells are indicated by the character ‘.’.</p>
<p>You may assume that there will be only one unique solution.<br><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"><br>A sudoku puzzle…<br><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png"><br>…and its solution numbers marked in red.</p>
<p>【解答】回溯法，每个可以填写数字的位置挨个试，用validate方法来验证当前的填写是否正确，不需要等整个board全部填完了再判断，每填写一个数就可以判断了。办法挺死板的，当时想着不行的话再想办法优化，不过居然AC了，真是……</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span>(<span class="keyword">char</span>[][] board) {</div><div class="line">        solve(board);</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">solve</span>(<span class="keyword">char</span>[][] board) {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; ++j) {</div><div class="line">                <span class="keyword">if</span> (<span class="string">'.'</span> == board[i][j]) {</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=<span class="number">9</span>; ++k) {</div><div class="line">                        board[i][j] = (<span class="keyword">char</span>)(<span class="string">'0'</span>+k);</div><div class="line">                         </div><div class="line">                        <span class="keyword">if</span> (validate(board, i, j) && solve(board))</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                         </div><div class="line">                        board[i][j] = <span class="string">'.'</span>;</div><div class="line">                    }</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="comment">// x: row, y: col</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span>(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y) {</div><div class="line">        <span class="comment">// col==y</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)</div><div class="line">            <span class="keyword">if</span> (i!=x && board[i][y]==board[x][y])</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">         </div><div class="line">        <span class="comment">// row==x</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">9</span>; j++)</div><div class="line">            <span class="keyword">if</span> (j!=y && board[x][j]==board[x][y])</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">         </div><div class="line">        <span class="comment">// each cube</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>*(x/<span class="number">3</span>); i&lt;<span class="number">3</span>*(x/<span class="number">3</span>+<span class="number">1</span>); i++)</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">3</span>*(y/<span class="number">3</span>); j&lt;<span class="number">3</span>*(y/<span class="number">3</span>+<span class="number">1</span>); j++)</div><div class="line">                <span class="keyword">if</span> (i!=x && j!=y && board[i][j]==board[x][y])</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="N-Queens"><span id="n-queens" style="color: #ff0000;">N-Queens</span></h3>
<p>【题目】The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br><img src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png"></p>
<p>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p>For example,<br>There exist two distinct solutions to the 4-queens puzzle:</p>
<pre><code>[
     [<span class="string">".Q.."</span>,  // Solution <span class="number">1</span>
      <span class="string">"...Q"</span>,
      <span class="string">"Q..."</span>,
      <span class="string">"..Q."</span>],

     [<span class="string">"..Q."</span>,  // Solution <span class="number">2</span>
      <span class="string">"Q..."</span>,
      <span class="string">"...Q"</span>,
      <span class="string">".Q.."</span>]
]
</code></pre><p>【解答】这个题目是比较经典的回溯法题目，很多教科书里面都有。根据国际象棋的规则，这里要求任意两个皇后不能在同一行，不能在同一列，不能在同一条对角线上。使用一个int数组来存放当前棋盘上皇后的状态，int[i]=j，表示第i行上，皇后放在第j列，这样天然避免了在同一行情况的出现，也避免了使用二维数组来保存状态；但是不能在同一列和不能在同一条对角线需要每次摆放一个皇后以后立马检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> List&lt;String[]&gt; <span class="title">solveNQueens</span>(<span class="keyword">int</span> n) {</div><div class="line">        List&lt;String[]&gt; list = <span class="keyword">new</span> ArrayList&lt;String[]&gt;();</div><div class="line">        solveNQueens(<span class="number">0</span>, n, <span class="keyword">new</span> <span class="keyword">int</span>[n], list);</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solveNQueens</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">int</span>[] positions,</div><div class="line">            List&lt;String[]&gt; list) {</div><div class="line">        <span class="keyword">if</span> (i == n) {</div><div class="line">            outputToList(n, positions, list);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</div><div class="line">                positions[i] = j; <span class="comment">// row: i, col: j</span></div><div class="line">                <span class="keyword">if</span> (validate(i, positions)) {</div><div class="line">                    solveNQueens(i + <span class="number">1</span>, n, positions, list);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outputToList</span>(<span class="keyword">int</span> n, <span class="keyword">int</span>[] positions, List&lt;String[]&gt; list) {</div><div class="line">        String[] result = <span class="keyword">new</span> String[n];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</div><div class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">             </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</div><div class="line">                <span class="keyword">if</span> (j == positions[i])</div><div class="line">                    sb.append(<span class="string">'Q'</span>);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    sb.append(<span class="string">'.'</span>);</div><div class="line">            }</div><div class="line">             </div><div class="line">            result[i] = sb.toString();</div><div class="line">        }</div><div class="line">         </div><div class="line">        list.add(result);</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span>(<span class="keyword">int</span> maxRow, <span class="keyword">int</span>[] positions) {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRow; i++) {</div><div class="line">            <span class="keyword">if</span> (positions[i] == positions[maxRow] <span class="comment">// same column</span></div><div class="line">                    || Math.abs(positions[i] - positions[maxRow]) == maxRow - i) <span class="comment">// catercorner line</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Minimum_Window_Substring"><span id="minimum-window-substring" style="color: #ff0000;">Minimum Window Substring</span></h3>
<p>【题目】Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>For example, S = “ADOBECODEBANC” T = “ABC”</p>
<p>Minimum window is “BANC”.</p>
<p>Note: If there is no such window in S that covers all characters in T, return the emtpy string “”.</p>
<p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.<br>【解答】注意题目要求的复杂度是n阶的，因此不能在循环中去匹配变化子串和T，那样就n的平方阶了。可以通过一个有限长的int数组来表达这个字符串T，大致思路如下：</p>
<p>双指针，一左一右，[left,right]这段区域内的子串就是待认定的window substring；<br>把T用一个长度为128的int数组来表达，下标表示字符的ascii码，值表示该字符在T中出现的次数；<br>整个流程就是是right和left分别尝试右移的过程，始终尽量保持[left,right]包含window substring：<br>    (1) 如果rightOrLeft为真，并且right能够右移，就右移并判定子串是否包含T，如果包含就判断是否需要更新min；如果包含或者干脆就不能右移，把移动的标志位置反。<br>    (2) 如果rightOrLeft为false，考虑left右移，并判定子串是否包含T，如果包含就判断是否需要更新min；如果不包含就把移动的标志位置反，让下次迭代去尝试right右移。<br>注意处理开头的特殊情况，即初始状态left==right==0，需要先把S[0]放到source里面去，避免遗漏。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    public <span class="type">String</span> minWindow(<span class="type">String</span> <span class="type">S</span>, <span class="type">String</span> <span class="type">T</span>) {</div><div class="line">        int[] target = <span class="keyword">new</span> int[<span class="number">128</span>];</div><div class="line">        <span class="keyword">for</span> (int i=<span class="number">0</span>; i&lt;<span class="type">T</span>.length(); i++) {</div><div class="line">            target[(int)(<span class="type">T</span>.charAt(i))]++;</div><div class="line">        }</div><div class="line">         </div><div class="line">        int <span class="keyword">left</span>=<span class="number">0</span>;</div><div class="line">        int <span class="keyword">right</span>=<span class="number">0</span>;</div><div class="line">        int[] source = <span class="keyword">new</span> int[<span class="number">128</span>];</div><div class="line">        source[(int)(<span class="type">S</span>.charAt(<span class="number">0</span>))]++;</div><div class="line">        <span class="type">String</span> <span class="built_in">min</span> = <span class="string">""</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="type">T</span>.equals(<span class="type">S</span>.substring(<span class="number">0</span>,<span class="number">1</span>)))</div><div class="line">            <span class="built_in">min</span> = <span class="type">S</span>.substring(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">        boolean rightOrLeft = <span class="built_in">true</span>; <span class="comment">// true: right, false: left</span></div><div class="line">         </div><div class="line">        <span class="keyword">while</span> (<span class="built_in">true</span>) {</div><div class="line">            <span class="keyword">if</span> (rightOrLeft) {</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">right</span>&lt;<span class="type">S</span>.length()-<span class="number">1</span>) {</div><div class="line">                    <span class="keyword">right</span>++;</div><div class="line">                    source[(int)(<span class="type">S</span>.charAt(<span class="keyword">right</span>))]++;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    rightOrLeft = <span class="built_in">false</span>;</div><div class="line">                }</div><div class="line">                 </div><div class="line">                <span class="keyword">if</span> (match(source, target)) {</div><div class="line">                    <span class="keyword">if</span> (<span class="string">""</span>.equals(<span class="built_in">min</span>) || <span class="built_in">min</span>.length()&gt;<span class="keyword">right</span>-<span class="keyword">left</span>+<span class="number">1</span>)</div><div class="line">                        <span class="built_in">min</span> = <span class="type">S</span>.substring(<span class="keyword">left</span>, <span class="keyword">right</span>+<span class="number">1</span>);</div><div class="line">                     </div><div class="line">                    rightOrLeft = <span class="built_in">false</span>;</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">left</span>==<span class="type">S</span>.length()-<span class="number">1</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                 </div><div class="line">                source[(int)(<span class="type">S</span>.charAt(<span class="keyword">left</span>))]--;</div><div class="line">                <span class="keyword">left</span>++;</div><div class="line">                 </div><div class="line">                <span class="keyword">if</span> (match(source, target)) {</div><div class="line">                    <span class="keyword">if</span> (<span class="string">""</span>.equals(<span class="built_in">min</span>) || <span class="built_in">min</span>.length()&gt;<span class="keyword">right</span>-<span class="keyword">left</span>+<span class="number">1</span>)</div><div class="line">                        <span class="built_in">min</span> = <span class="type">S</span>.substring(<span class="keyword">left</span>, <span class="keyword">right</span>+<span class="number">1</span>);</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    rightOrLeft = <span class="built_in">true</span>;</div><div class="line">                }</div><div class="line">            } <span class="comment">// else</span></div><div class="line">        } <span class="comment">// while</span></div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</div><div class="line">    }</div><div class="line">     </div><div class="line">    private boolean match(int[] <span class="keyword">left</span>, int[] <span class="keyword">right</span>) {</div><div class="line">        <span class="keyword">for</span> (int i=<span class="number">0</span>; i&lt;<span class="number">128</span>; i++) {</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">left</span>[i]&lt;<span class="keyword">right</span>[i])</div><div class="line">                <span class="keyword">return</span> <span class="built_in">false</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="built_in">true</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Merge_k_Sorted_Lists"><span id="merge-k-sorted-lists" style="color: #ff0000;">Merge k Sorted Lists</span></h3>
<p>【题目】Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p>【解答】这道题是有一定典型意义的。如果是两个列表归并，那么显然就使用传统归并排序的方法就好了，但是现在是m个列表归并，这就意味着，在每一轮归并的迭代中，假使每个列表取一个元素，那么着m个元素的大小关系是完全不可知的，原有排好序的list特性并没有充分利用，这能优化吗？</p>
<p>进一步考虑，在对刚才说的m个元素排序以后，比如说我就知道了最小元素是来自7号链表的，那么，我可以想象，最终结果中，次小元素要么在当前这剩下的m-1个元素里面，要么就是7号链表剩下元素的头部了。要充分利用这个信息，才可以让算法的复杂度降下来。</p>
<p>要不断取得这m个元素中最小的，于是我联想到了堆排序（各种排序方法，包括堆排序，我以前在这篇文中总结过）。每次从最小堆中抽走堆顶，接下去就补充被抽走堆顶的next元素到堆中，重新恢复最小堆。分析一下复杂度，按照刚才的定义，全部元素是(m<em>n)，堆大小是m，那么整个复杂度就是m</em>n(log m)。</p>
<p>在Java中，其实已经有封装好堆排序的现成的东西了（这是个死知识），那个东西就是PriorityQueue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> ListNode <span class="title">mergeKLists</span>(List&lt;ListNode&gt; lists) {</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==lists || lists.isEmpty())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">         </div><div class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.size(), <span class="keyword">new</span> Comparator&lt;ListNode&gt;(){</div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(ListNode n1, ListNode n2) {</div><div class="line">                <span class="keyword">if</span> (n1.val==n2.val)</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n1.val&lt;n2.val)</div><div class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            }</div><div class="line">        });</div><div class="line">         </div><div class="line">        <span class="comment">// initialization</span></div><div class="line">        <span class="keyword">for</span> (ListNode n : lists) {</div><div class="line">            <span class="keyword">if</span> (n==<span class="keyword">null</span>)</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">                 </div><div class="line">            queue.add(n);</div><div class="line">        }</div><div class="line">         </div><div class="line">        ListNode fakeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode current = fakeHead;</div><div class="line">         </div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</div><div class="line">            ListNode n = queue.poll();</div><div class="line">            current.next = n;</div><div class="line">            current = n;</div><div class="line">            <span class="keyword">if</span> (n.next!=<span class="keyword">null</span>)</div><div class="line">                queue.add(n.next);</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> fakeHead.next;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Merge_Intervals"><span id="merge-intervals" style="color: #ff0000;">Merge Intervals</span></h3>
<p>【题目】Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,<br>Given [1,3],[2,6],[8,10],[15,18],<br>return [1,6],[8,10],[15,18].</p>
<p>【解答】这题相对来说比较简单。先排序，按照start属性来排。之后开始遍历intervals，如果发现有重叠的interval，就合并；如果发现非重叠的interval，放置较靠前的一个到最终的list里面去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span>(List&lt;Interval&gt; intervals) {</div><div class="line">        Collections.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;(){</div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(Interval left, Interval right) {</div><div class="line">                <span class="keyword">if</span> (left.start == right.start)</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (left.start &lt; right.start)</div><div class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            }</div><div class="line">        });</div><div class="line">         </div><div class="line">        List&lt;Interval&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        Interval toCompare = <span class="keyword">null</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">for</span> (Interval interval : intervals) {</div><div class="line">            <span class="keyword">if</span> (toCompare!=<span class="keyword">null</span> && interval.end&gt;=toCompare.start && interval.start&lt;=toCompare.end) {</div><div class="line">                toCompare.start = Math.min(interval.start, toCompare.start);</div><div class="line">                toCompare.end = Math.max(interval.end, toCompare.end);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">if</span> (toCompare!=<span class="keyword">null</span>)</div><div class="line">                    list.add(toCompare);</div><div class="line">                toCompare = interval;</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>!=toCompare)</div><div class="line">            list.add(toCompare);</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Scramble_String"><span id="scramble-string" style="color: #ff0000;">Scramble String</span></h3>
<p>【题目】Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of s1 = “great”:</p>
<pre><code>    great
   /    <span class="command">\
</span>  gr    eat
 / <span class="command">\ </span>   /  <span class="command">\
</span>g   r  e   at
           / <span class="command">\
</span>          a   t
</code></pre><p>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node “gr” and swap its two children, it produces a scrambled string “rgeat”.</p>
<pre><code>    rgeat
   /    <span class="command">\
</span>  rg    eat
 / <span class="command">\ </span>   /  <span class="command">\
</span>r   g  e   at
           / <span class="command">\
</span>          a   t
</code></pre><p>We say that “rgeat” is a scrambled string of “great”.</p>
<p>Similarly, if we continue to swap the children of nodes “eat” and “at”, it produces a scrambled string “rgtae”.</p>
<pre><code>    rgtae
   /    <span class="command">\
</span>  rg    tae
 / <span class="command">\ </span>   /  <span class="command">\
</span>r   g  ta  e
       / <span class="command">\
</span>      t   a
</code></pre><p>We say that “rgtae” is a scrambled string of “great”.</p>
<p>Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.</p>
<p>【解答】终于做到一道3维动态规划的题目了。最开始我就是简单的回溯遍历，结果执行超时了，于是想到DP。cache[i][j][k]表示的是，s1以下标i为起点，s2以下标j为起点，二者长度都为k时，这两个子串是否满足scramble关系，即s1的[i,i+k)和s2的[j,j+k)是否满足scramble关系。</p>
<p>这一点不难想到，并且想到以后就可以落实代码了。但是在写代码判断scramble关系的时候，考虑swap和非swap两种情况，而且很容易写错：</p>
<p>s1的[start1,start1+i)和s2的[start2,start2+i)满足scramble关系，并且s1的[start1+i,start1+len)和s2的[start2+i, start2+len)也满足scramble关系，这种情况是两个子串没有发生swap的；<br>另一种情况自然就是两个子串发生了swap，即s1的[start1+len-i,start1+len)和s2的[start2, start2+i)满足scramble关系，并且s1的[start1,start1+len-i)和s2的[start2+i,start2+len)也满足scrmable关系。<br>上面两种情况只需具备其一就返回true，像这种比较绕的DP题目，我觉得写出数学通式是最关键的一步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span>(String s1, String s2) {</div><div class="line">        <span class="keyword">if</span> (s1.length()!=s2.length())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">         </div><div class="line">        <span class="comment">// cache[i][j][k]: scramble between s1:[i,i+k) and s2:[j,j+k)</span></div><div class="line">        Boolean[][][] cache = <span class="keyword">new</span> Boolean[s1.length()][s1.length()][s1.length()+<span class="number">1</span>];</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> isScramble(s1, s2, <span class="number">0</span>, <span class="number">0</span>, s1.length(), cache);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isScramble</span>(String s1, String s2, <span class="keyword">int</span> start1, <span class="keyword">int</span> start2, <span class="keyword">int</span> len, Boolean[][][] cache) {</div><div class="line">        <span class="keyword">if</span> (cache[start1][start2][len]!=<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> cache[start1][start2][len];</div><div class="line">         </div><div class="line">        <span class="comment">// exit</span></div><div class="line">        <span class="keyword">if</span> (len==<span class="number">1</span>) {</div><div class="line">            cache[start1][start2][len] = s1.charAt(start1)==s2.charAt(start2);</div><div class="line">            <span class="keyword">return</span> cache[start1][start2][len];</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="comment">// s1:[start1, start1+i) &lt;=&gt; s2:[start2, start2+i) and s1:[start1+i, start1+len) &lt;=&gt; s2:[start2+i, start2+len)</span></div><div class="line">        <span class="comment">// or</span></div><div class="line">        <span class="comment">// s1:[start1+len-i, start1+len) &lt;=&gt; s2:[start2, start2+i) and s1:[start1, start1+len-i) &lt;=&gt; s2:[start2+i, start2+len)</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++) {</div><div class="line">            <span class="keyword">if</span> (</div><div class="line">                (isScramble(s1, s2, start1, start2, i, cache) && isScramble(s1, s2, start1+i, start2+i, len-i, cache))</div><div class="line">                ||</div><div class="line">                (isScramble(s1, s2, start1+len-i, start2, i, cache) && isScramble(s1, s2, start1, start2+i, len-i, cache))</div><div class="line">            ) {</div><div class="line">                cache[start1][start2][len] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        cache[start1][start2][len] = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Trapping_Rain_Water"><span id="trapping-rain-water" style="color: #ff0000;">Trapping Rain Water</span></h3>
<p>【题目】Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.<br><img src="http://www.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png"><br>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p>【解答】这道题是hard里面相对比较简单的。大致的思路就是，找最长的两根杆子，分别为最长和次长，而两根杆子中间的部分，每个位置都去算距离次长杆子的距离，这些距离累加起来就是这两根杆子中间部分可以trap的雨水的量，而对于这两根杆子两侧的部分，继续递归求解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span>(<span class="keyword">int</span>[] A) {</div><div class="line">        <span class="keyword">return</span> trap(A, <span class="number">0</span>, A.length-<span class="number">1</span>);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="comment">// [start, end]</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">trap</span>(<span class="keyword">int</span>[] A, <span class="keyword">int</span> start, <span class="keyword">int</span> end) {</div><div class="line">        <span class="keyword">if</span> (start+<span class="number">1</span>&gt;=end)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> maxIndex = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> secondMaxIndex = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;=end; i++) {</div><div class="line">            <span class="keyword">if</span> (secondMaxIndex==-<span class="number">1</span> || A[i]&gt;A[secondMaxIndex]) {</div><div class="line">                secondMaxIndex = i;</div><div class="line">                 </div><div class="line">                <span class="keyword">if</span> (maxIndex==-<span class="number">1</span> || A[secondMaxIndex]&gt;A[maxIndex]) {</div><div class="line">                    <span class="keyword">int</span> temp = maxIndex;</div><div class="line">                    maxIndex = secondMaxIndex;</div><div class="line">                    secondMaxIndex = temp;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> left = Math.min(maxIndex, secondMaxIndex);</div><div class="line">        <span class="keyword">int</span> right = Math.max(maxIndex, secondMaxIndex);</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> leftPart = trap(A, start, left);</div><div class="line">        <span class="keyword">int</span> rightPart = trap(A, right, end);</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> midPart = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=left+<span class="number">1</span>; i&lt;right; i++) {</div><div class="line">            midPart += A[secondMaxIndex] - A[i];</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> leftPart+midPart+rightPart;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Median_of_Two_Sorted_Arrays"><span id="median-of-two-sorted-arrays" style="color: #ff0000;">Median of Two Sorted Arrays</span></h3>
<p>【题目】There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>【解答】首先要明确中位数的概念：在A和B的总数为奇数时，中位数是中间那个数；总数为偶数时，中位数是中间那两个数的算术平均数。</p>
<p>这道题麻烦的地方在于时间复杂度是log(m+n)，要得到这种时间复杂度，每个数遍历一遍显然是不可能的。于是就要充分利用好A和B都是有序的特点，而联想到二分搜索的时间复杂度恰好是log(n)，所以思路就是看看能不能利用或者借鉴上二分搜索。</p>
<p>再一个如果强化一下条件，假设这里m==n，那么拿A的中位数和B的中位数比较，如果A的中位数比较大，那么最后我们要求的A并B的中位数应该在B的后半段+A的前半段里，这样可以一直递归求解。现在m不一定等于n，这个结论也依然成立，每次分别比较A和B的中位数后可以给A、B分别砍掉半支，这样最后求解的复杂度恰好就是O(log(m+n))。</p>
<p>在求中位数的时候小心坐标运算的时候发生错误，我反正错了N次。思路好找，要写对还挺难的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span>(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[]) {</div><div class="line">        <span class="keyword">if</span> ((A.length + B.length) % <span class="number">2</span> == <span class="number">0</span>) {</div><div class="line">            <span class="keyword">int</span> midLeft = (A.length + B.length) / <span class="number">2</span> - <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> midRight = (A.length + B.length) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">return</span> (<span class="number">0.0</span> + find(A, B, midRight, <span class="number">0</span>, A.length - <span class="number">1</span>, <span class="number">0</span>, B.length - <span class="number">1</span>) + find(</div><div class="line">                    A, B, midLeft, <span class="number">0</span>, A.length - <span class="number">1</span>, <span class="number">0</span>, B.length - <span class="number">1</span>)) / <span class="number">2</span>;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">int</span> mid = (A.length + B.length) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) find(A, B, mid, <span class="number">0</span>, A.length - <span class="number">1</span>, <span class="number">0</span>, B.length - <span class="number">1</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span>(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> i, <span class="keyword">int</span> aStart, <span class="keyword">int</span> aEnd, <span class="keyword">int</span> bStart,</div><div class="line">            <span class="keyword">int</span> bEnd) {</div><div class="line"> </div><div class="line">        <span class="keyword">if</span> (aEnd - aStart &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> B[bStart + i];</div><div class="line">        <span class="keyword">if</span> (bEnd - bStart &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> A[aStart + i];</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> A[aStart] &lt; B[bStart] ? A[aStart] : B[bStart];</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> aRelativePos = (<span class="keyword">int</span>) (((<span class="number">0.0</span> + (aEnd - aStart + <span class="number">1</span>)) / ((aEnd</div><div class="line">                - aStart + <span class="number">1</span>) + (bEnd - bStart + <span class="number">1</span>))) * i);</div><div class="line">        <span class="keyword">int</span> aMid = aRelativePos + aStart;</div><div class="line">        <span class="keyword">int</span> bMid = i - aRelativePos - <span class="number">1</span> + bStart;</div><div class="line"> </div><div class="line">        <span class="keyword">if</span> (A[aMid] &gt; B[bMid]) {</div><div class="line">            i -= bMid - bStart + <span class="number">1</span>;</div><div class="line">            aEnd = aMid;</div><div class="line">            bStart = bMid + <span class="number">1</span>;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            i -= aMid - aStart + <span class="number">1</span>;</div><div class="line">            bEnd = bMid;</div><div class="line">            aStart = aMid + <span class="number">1</span>;</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> find(A, B, i, aStart, aEnd, bStart, bEnd);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Maximal_Rectangle"><span id="maximal-rectangle" style="color: #ff0000;">Maximal Rectangle</span></h3>
<p>【题目】Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p>
<p>【解答】首先要理解题意，这里说的是要求这个矩形里面包含1，并且是只包含1，“rectangle containing all ones”，反正开始我是没有理解出，这句话是表示“只”包含1的。</p>
<p>比如这样一幅图：</p>
<p>1 0 1 0 1</p>
<p>1 1 1 0 0</p>
<p>0 1 1 0 1</p>
<p>那么这个矩形应该是用下划线标出的区域，因此应该返回4。</p>
<p>那怎么做呢？先降维思考一下，如果matrix只有一维，那就好办了，寻找连续的1，连续最多的就是最大的值。现在是二维，也可以往一维上面靠，做法就是：从上往下一行一行遍历，每一行的每个元素，都表示和上一行同一列连通（上下都是1就表示连通）的累加值。也就是说，上面这个图变成了：</p>
<p>1 0 1 0 1</p>
<p>2 1 2 0 0</p>
<p>0 2 2 0 1</p>
<p>只有上下连通，才会被累加，如果断掉了，就置为0。</p>
<p>现在，每一行遍历完毕的时候，我拿到该行的结果，就可以去计算截止到该行为止的最大值了。</p>
<p>比如最后这行：</p>
<p>0 2 2 0 1</p>
<p>把这个数组（命名为acc）画成等价的柱状图就是：<br><img src="http://www.raychase.net/wp-content/uploads/2015/01/chartchart1.png"><br>我拿Excel草草画的图，但是可见要求最大的矩形应该就是acc[1]和acc[2]的和，为4。但是在求最大值的时候，需要按照高度从1到acc里元素的最大值为上限依次遍历，寻找连续块的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span>(<span class="keyword">char</span>[][] matrix) {</div><div class="line">        <span class="keyword">if</span> (matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">int</span>[] acc = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.length; i++) {</div><div class="line">            <span class="keyword">int</span> singleMax = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[i].length; j++) {</div><div class="line">                <span class="keyword">if</span> (matrix[i][j]==<span class="string">'0'</span>) {</div><div class="line">                    acc[j] = <span class="number">0</span>;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    acc[j]++;</div><div class="line">                     </div><div class="line">                    <span class="keyword">if</span> (acc[j]&gt;singleMax)</div><div class="line">                        singleMax = acc[j];</div><div class="line">                }</div><div class="line">            }</div><div class="line">             </div><div class="line">            <span class="keyword">int</span> newMax = calculateMax(acc, singleMax);</div><div class="line">            <span class="keyword">if</span> (newMax&gt;max)</div><div class="line">                max = newMax;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateMax</span>(<span class="keyword">int</span>[] acc, <span class="keyword">int</span> singleMax) {</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=singleMax; i++) {</div><div class="line">            <span class="keyword">int</span> accInRow = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;acc.length; j++) {</div><div class="line">                <span class="keyword">if</span> (acc[j]&gt;=i) {</div><div class="line">                    accInRow += i;</div><div class="line">                     </div><div class="line">                    <span class="keyword">if</span> (accInRow&gt;max)</div><div class="line">                        max = accInRow;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    accInRow = <span class="number">0</span>;</div><div class="line">                } <span class="comment">// else</span></div><div class="line">            } <span class="comment">// for j</span></div><div class="line">        } <span class="comment">// for i</span></div><div class="line">         </div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>AC了，代码其实并不复杂，但是其实复杂度够高的，达到了O(x<em>y</em>m)，其中x和y分别表示矩阵的长和宽，m表示某一行上积累的最大高度（acc里的最大值）。</p>
<p>当然，网传有更牛逼更简洁的解法，也更不好懂，<a href="http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html" target="_blank" rel="external">这篇文章</a>提到，我就不贴了。</p>
<h3 id="Max_Points_on_a_Line"><span id="max-points-on-a-line" style="color: #ff0000;">Max Points on a Line</span></h3>
<p>题目】Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>【解答】最开始我的做法是，O(n^2)的复杂度，每取得两个点，就可以列出一个直线方程：y=kx+b，并把该直线方程放到一个map里面去，后续出现新的直线的时候都要先到map里面去寻找是否能够找到重合的直线，但是值得注意的有两处：</p>
<p>k和b都要表示成分数，不要使用double或者float，否则可能损失精度，比较两个float或者double的大小可能是不准确的；<br>在直线垂直于x轴的时候，原有方程不存在，直线方程为x=x0。<br>不过原始代码却执行超时了。</p>
<p>在此基础上整理一下思路，下面的解法AC，getCount方法，是对于给定的两个点p1、p2，寻找Point[]数组里面和p1、p2形成的直线斜率相同的点的个数（注意时刻都不要使用真正求斜率的除法，因为那样会引入double或者float型，丢失精度）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span>(Point[] points) {</div><div class="line">        <span class="keyword">if</span> (points.length &lt;= <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> points.length;</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.length; j++) {</div><div class="line">                <span class="keyword">if</span> (points[i] == points[j])</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">int</span> count = getCount(points, points[i], points[j]);</div><div class="line">                <span class="keyword">if</span> (count &gt; maxCount)</div><div class="line">                    maxCount = count;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> maxCount;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span>(Point[] points, Point p1, Point p2) {</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"> </div><div class="line">        <span class="comment">// vertical</span></div><div class="line">        <span class="keyword">if</span> (p1.x == p2.x) {</div><div class="line">            <span class="keyword">for</span> (Point p : points) {</div><div class="line">                <span class="keyword">if</span> (p.x == p1.x)</div><div class="line">                    count++;</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> count;</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="comment">// horizontal</span></div><div class="line">        <span class="keyword">if</span> (p1.y == p2.y) {</div><div class="line">            <span class="keyword">for</span> (Point p : points) {</div><div class="line">                <span class="keyword">if</span> (p.y == p1.y)</div><div class="line">                    count++;</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> count;</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="keyword">for</span> (Point p : points) {</div><div class="line">            <span class="comment">// gradient: (p2.y-p1.y)/(p2.x-p1.x)</span></div><div class="line">            <span class="keyword">if</span> ((p.y - p2.y) * (p1.x - p2.x) == (p1.y - p2.y) * (p.x - p2.x)) {</div><div class="line">                count++;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="LRU_Cache"><span id="lru-cache" style="color: #ff0000;">LRU Cache</span></h3>
<p>【题目】Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>【解答】这里应用一点小知识，LinkedHashMap其实已经把这个LRU的事情做好了，只要覆写removeEldestEntry方法，判断如果大小大过容量，就返回true。构造方法，需要调用父类构造方法，传入的三个参数分别表示：初始大小、扩容增长因子、访问顺序（accessOrder）。其中第三个参数尤其重要，accessOrder为true时，每次调用get方法访问行为发生后，会把最近访问的对象移动到头部，而超出容量移除对象时，是从尾部开始的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</div><div class="line"> </div><div class="line">class LRULinkedHashMap extends LinkedHashMap&lt;Integer, Integer&gt; {</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</div><div class="line">    <span class="keyword">public</span> <span class="title">LRULinkedHashMap</span>(<span class="keyword">int</span> capacity) {</div><div class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75</span>F, <span class="keyword">true</span>);</div><div class="line">        <span class="keyword">this</span>.capacity = capacity;</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span>(Map.Entry paramEntry) {</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.entrySet().size()&gt;capacity)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"> </div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>{</div><div class="line">    <span class="keyword">private</span> LRULinkedHashMap map;</div><div class="line">     </div><div class="line">    <span class="keyword">public</span> <span class="title">LRUCache</span>(<span class="keyword">int</span> capacity) {</div><div class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> LRULinkedHashMap(capacity);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span>(<span class="keyword">int</span> key) {</div><div class="line">        Integer result = <span class="keyword">this</span>.map.get(key);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==result)</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value) {</div><div class="line">        <span class="keyword">this</span>.map.put(key, value);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Longest_Valid_Parentheses"><span id="longest-valid-parentheses" style="color: #ff0000;">Longest Valid Parentheses</span></h3>
<p>【题目】Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p>
<p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
<p>【解答】这道题也算hard里面相对简单的。基本思路是DP，但是最开始我用递归，从长串往短串方向递归调用，结果一个长case让我栈溢出了。于是改成循环，从短串往长串遍历（i从小到大），而在每次迭代中从右向左寻找包含s[i]的合法序列（j从大到小）：</p>
<p>每次循环迭代都拿包含s[i]的括号序列和不包含s[i]的括号序列（即前一次迭代的结果）比较，取较大值留下来。比如()()，i==2时，s[2]是(，结果是2；i==3时，s[3]是)，最长串是4，结果是2和4的最大值，为4。<br>用rightNum变量记录目前多余的右括号，需要继续找左括号来匹配。如果rightNum&lt;0，就要跳出本次迭代，因为左括号太多了，而右括号又必须先于左括号出现（因为j从大到小变化），允许合法出现的机会已经错过了；只有当rightNum变为0时，表示当前的串是一个合法的结果，更新accumation为当前串的长度len。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span>(String s) {</div><div class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) {</div><div class="line">            <span class="keyword">int</span> rightNum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> accumulation = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;=<span class="number">0</span>; j--) {</div><div class="line">                <span class="keyword">char</span> ch = s.charAt(j);</div><div class="line">                <span class="keyword">if</span> (ch==<span class="string">')'</span>) {</div><div class="line">                    rightNum++;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    rightNum--;</div><div class="line">                    <span class="keyword">if</span> (rightNum&lt;<span class="number">0</span>)</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                     </div><div class="line">                    len += <span class="number">2</span>;</div><div class="line">                    <span class="keyword">if</span> (rightNum==<span class="number">0</span>)</div><div class="line">                        accumulation = len;</div><div class="line">                }</div><div class="line">            }</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (accumulation&gt;longest)</div><div class="line">                longest = accumulation;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> longest;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Longest_Consecutive_Sequence"><span id="longest-consecutive-sequence" style="color: #ff0000;">Longest Consecutive Sequence</span></h3>
<p>【题目】Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given <code>[100, 4, 200, 1, 3, 2]</code>,<br>The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its length: <code>4</code>.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<p>【解答】这道题的关键在于时间复杂度要求是O(n)的，这就意味着，排序不用想了，而遍历这个数组的时候，还得用常量时间复杂度去做额外的操作。如果拼命去想怎么从原数组里面挨个取出元素来，怎么放到某一个容器里面，在整个数组便利完成之后，要让这个最长序列的结果也得出来的话，就走入死胡同了。原因在于，比如有序列1,2,3,4的话，当你2先放入容器，4再放入的时候，很难找到和2之间的关联。但是，反过来就不一样了。先把所有的数都一股脑儿倒到一个set里面去，然后从中任取一个数，接着这个数开始往大的序列和往小的序列都挨个尝试从这个set里面取出来，取到说明有连续串，一直取到这一串数断掉为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span>(<span class="keyword">int</span>[] num) {</div><div class="line">        <span class="keyword">if</span> (num==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">             </div><div class="line">        Set&lt;Integer&gt; total = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : num) {</div><div class="line">            total.add(n);</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!total.isEmpty()) {</div><div class="line">            <span class="keyword">int</span> n = total.iterator().next();</div><div class="line">            total.remove(n);</div><div class="line">             </div><div class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">             </div><div class="line">            <span class="keyword">int</span> i = n;</div><div class="line">            <span class="keyword">while</span> (total.remove(++i))</div><div class="line">                count++;</div><div class="line">             </div><div class="line">            i = n;</div><div class="line">            <span class="keyword">while</span> (total.remove(--i))</div><div class="line">                count++;</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (count&gt;max)</div><div class="line">                max = count;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Copy_List_with_Random_Pointer"><span id="copy-list-with-random-pointer" style="color: #ff0000;">Copy List with Random Pointer</span></h3>
<p>【题目】A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<p>【解答】这题比较简单。首先，按照不考虑random属性的情况，过一遍这个list，创建一个新的list，但是，每过到一个节点的时候，就以&lt;老节点,新节点&gt;这样的组合放到map里面去。之后再过第二遍的时候，对于每一个老节点，以及它的random属性所指向的节点，都可以在这个map里面找到对应的新节点。</p>
<p>对于新建的链表，下面使用了一个fakeTargetHead来简化代码，避免head的特殊判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span>(RandomListNode head) {</div><div class="line">        Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">         </div><div class="line">        RandomListNode fakeTargetHead = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</div><div class="line">         </div><div class="line">        RandomListNode src = head;</div><div class="line">        RandomListNode target = fakeTargetHead;</div><div class="line">        <span class="keyword">while</span> (src!=<span class="keyword">null</span>) {</div><div class="line">            RandomListNode node = <span class="keyword">new</span> RandomListNode(src.label);</div><div class="line">            map.put(src, node);</div><div class="line">             </div><div class="line">            target.next = node;</div><div class="line">             </div><div class="line">            src = src.next;</div><div class="line">            target = target.next;</div><div class="line">        }</div><div class="line">         </div><div class="line">        src = head;</div><div class="line">        <span class="keyword">while</span> (src!=<span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span>!=src.random) {</div><div class="line">                RandomListNode node = map.get(src);</div><div class="line">                RandomListNode to = map.get(src.random);</div><div class="line">                 </div><div class="line">                node.random = to;</div><div class="line">            }</div><div class="line">             </div><div class="line">            src = src.next;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> fakeTargetHead.next;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Largest_Rectangle_in_Histogram"><span id="largest-rectangle-in-histogram" style="color: #ff0000;">Largest Rectangle in Histogram</span></h3>
<p>【题目】Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br><img src="http://www.leetcode.com/wp-content/uploads/2012/04/histogram.png"><br>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].<br><img src="http://www.leetcode.com/wp-content/uploads/2012/04/histogram_area.png"><br>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>For example,</p>
<p>Given height = [2,1,5,6,2,3],<br>return 10.</p>
<p>【解答】这个题目可以看作是《Maximal Rectangle》中间的一部分，但是它时间上面的要求，要比那道题高得多。因此我一开始使用解那道题里面的办法来解，就超时了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span>(<span class="keyword">int</span>[] height) {</div><div class="line">        <span class="keyword">if</span> (height==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">             </div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h : height)</div><div class="line">            <span class="keyword">if</span> (h&gt;max)</div><div class="line">                max = h;</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> largest = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=max; i++) {</div><div class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h : height) {</div><div class="line">                <span class="keyword">if</span> (h&gt;=i) {</div><div class="line">                    total += i;</div><div class="line">                     </div><div class="line">                    <span class="keyword">if</span> (total&gt;largest)</div><div class="line">                        largest = total;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    total = <span class="number">0</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> largest;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>导致超时的case是[0,0,0,0,0,0,0,0,2147483647]，显然，我让i从1循环到2147483674，这太不合理了。于是我想，i不需要循环那么多，只需要循环height数组里面的那几个数就可以了，而height数组里面的数是可能有重复的，如果case有1000个1怎么办，其实i只需要取一次1就可以了，因此引入一个HashSet来去重：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span>(<span class="keyword">int</span>[] height) {</div><div class="line">        <span class="keyword">if</span> (height==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">         </div><div class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h : height)</div><div class="line">            <span class="keyword">if</span> (!set.contains(h))</div><div class="line">                set.add(h);</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> largest = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : set) {</div><div class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h : height) {</div><div class="line">                <span class="keyword">if</span> (h&gt;=i) {</div><div class="line">                    total += i;</div><div class="line">                     </div><div class="line">                    <span class="keyword">if</span> (total&gt;largest)</div><div class="line">                        largest = total;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    total = <span class="number">0</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> largest;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>刚才那个case确实过了，但是碰到一个巨长无比的case又嗝屁了，归根到底这也是个n平方的复杂度。在网上这道题我找到了很多解法，有的解法虽然能AC，但是只是针对case做了优化，换一种类型的case其实还是会挂，因此并没有从实际上解决问题，但是，看看下面这个办法（来自<a href="http://blog.csdn.net/doc_sgl/article/details/11805519" target="_blank" rel="external">这个blog</a>），大致是思路就是从左往右遍历，用一个栈来存储递增的高度序列，如果发现高度递减，停止入栈，并不断出栈以分别计算以之前栈内存放的每个高度作为最终高度的矩形面积。具体解法刚才的blog链接上叙述得非常清楚了，图文并茂。这个办法是非常漂亮的，简洁清晰，而且时间复杂度也要低得多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span>(<span class="keyword">int</span>[] height) {</div><div class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">while</span> (i &lt;= height.length) {</div><div class="line">            <span class="keyword">int</span> currentHeight = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (i != height.length)</div><div class="line">                currentHeight = height[i];</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (stk.empty() || height[stk.peek()] &lt;= currentHeight) {</div><div class="line">                stk.push(i++);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">int</span> t = stk.pop();</div><div class="line">                maxArea = Math.max(maxArea, height[t] * (stk.empty() ? i : i - stk.peek() - <span class="number">1</span>));</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Jump_Game_II"><span id="jump-game-ii" style="color: #ff0000;">Jump Game II</span></h3>
<p>【题目】Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>For example:<br>Given array A = <code>[2,3,1,1,4]</code></p>
<p>The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)</p>
<p>【解答】这个题目在hard的题目里算是简单的。在任意一个位置，都存在着当前jump数值可达的范围[x,range]，还存在着该区间的一系列A[i]+i所取的最大值nextRange，当i&gt;range时，更新range为原nextRange，并且jump数加一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span>(<span class="keyword">int</span>[] A) {</div><div class="line">        <span class="keyword">if</span> (A.length == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> jump = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> range = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> nextRange = <span class="number">0</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) {</div><div class="line">            <span class="keyword">if</span> (range &lt; i) {</div><div class="line">                <span class="keyword">if</span> (i &lt;= nextRange) {</div><div class="line">                    jump++;</div><div class="line">                    range = nextRange;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// unreachable</span></div><div class="line">                }</div><div class="line">            }</div><div class="line"> </div><div class="line">            <span class="keyword">if</span> (A[i] + i &gt; nextRange)</div><div class="line">                nextRange = A[i] + i;</div><div class="line"> </div><div class="line">            <span class="keyword">if</span> (i == A.length - <span class="number">1</span>)</div><div class="line">                <span class="keyword">return</span> jump;</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// impossible</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Interleaving_String"><span id="interleaving-string" style="color: #ff0000;">Interleaving String</span></h3>
<p>【题目】Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Given:<br>s1 = <code>&quot;aabcc&quot;</code>,<br>s2 = <code>&quot;dbbca&quot;</code>,</p>
<p>When s3 = <code>&quot;aadbbcbcac&quot;</code>, return true.<br>When s3 = <code>&quot;aadbbbaccc&quot;</code>, return false.</p>
<p>【解答】这道题给我的第一感觉就是使用<code>回溯法</code>，分别从s1、s2和s3取一个字符，分别命名为c1、c2和c3，如果c1==c3而c2!=c3，那么这个字符从s1取；如果c2==c3而c1!=c3，那么字符从s2取。麻烦的是c1==c3且c2==c3的情况，相当于回溯的路径出现了分支，于是我使用一个stack来存放分支。最终回溯的路径会是深度优先遍历一棵二叉树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">class Fork {</div><div class="line">    <span class="keyword">int</span> i1;</div><div class="line">    <span class="keyword">int</span> i2;</div><div class="line">    <span class="keyword">int</span> i3;</div><div class="line">     </div><div class="line">    <span class="keyword">public</span> <span class="title">Fork</span>(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> i3) {</div><div class="line">        <span class="keyword">this</span>.i1 = i1;</div><div class="line">        <span class="keyword">this</span>.i2 = i2;</div><div class="line">        <span class="keyword">this</span>.i3 = i3;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span>(String s1, String s2, String s3) {</div><div class="line">        <span class="keyword">if</span> (s1.length()+s2.length()!=s3.length())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">             </div><div class="line">        <span class="keyword">int</span> i1=<span class="number">0</span>, i2=<span class="number">0</span>, i3=<span class="number">0</span>;</div><div class="line">        Stack&lt;Fork&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">         </div><div class="line">        <span class="keyword">while</span> ((i1&lt;s1.length() && i2&lt;s2.length()) || !stack.isEmpty()) {</div><div class="line">            <span class="keyword">char</span> c1 = <span class="number">0</span>;</div><div class="line">            <span class="keyword">char</span> c2 = <span class="number">0</span>;</div><div class="line">            <span class="keyword">char</span> c3 = <span class="number">0</span>;</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (i1&lt;s1.length())</div><div class="line">                c1 = s1.charAt(i1);</div><div class="line">            <span class="keyword">if</span> (i2&lt;s2.length())</div><div class="line">                c2 = s2.charAt(i2);</div><div class="line">            <span class="keyword">if</span> (i3&lt;s3.length())</div><div class="line">                c3 = s3.charAt(i3);</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> ( c1==<span class="number">0</span> || c2==<span class="number">0</span> || (c1!=c3&&c2!=c3) ) {</div><div class="line">                <span class="keyword">if</span> (stack.isEmpty())</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                 </div><div class="line">                Fork fork = stack.pop();</div><div class="line">                i1 = fork.i1;</div><div class="line">                i2 = fork.i2;</div><div class="line">                i3 = fork.i3;</div><div class="line">                 </div><div class="line">                i2++;</div><div class="line">                i3++;</div><div class="line">                 </div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            }</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (c1==c3 && c2==c3) {</div><div class="line">                Fork fork = <span class="keyword">new</span> Fork(i1,i2,i3);</div><div class="line">                stack.push(fork);</div><div class="line">                i1++;</div><div class="line">                i3++;</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (c1==c3) {</div><div class="line">                i1++;</div><div class="line">                i3++;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                i2++;</div><div class="line">                i3++;</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">while</span> (i1&lt;s1.length()) {</div><div class="line">            <span class="keyword">char</span> c1 = s1.charAt(i1);</div><div class="line">            <span class="keyword">char</span> c3 = s3.charAt(i3);</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (c1!=c3)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">             </div><div class="line">            i1++;</div><div class="line">            i3++;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">while</span> (i2&lt;s2.length()) {</div><div class="line">            <span class="keyword">char</span> c2 = s2.charAt(i2);</div><div class="line">            <span class="keyword">char</span> c3 = s3.charAt(i3);</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (c2!=c3)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">             </div><div class="line">            i2++;</div><div class="line">            i3++;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是很快遇到某case的时候超时了，仔细分析了一下这个方法，最好的情况下时间复杂度是n阶，最坏的情况下时间复杂度达到了2的n次方阶。</p>
<p>现在换个思路，不是从前往后，而是从后往前想，假如说result[i][j]表示s1的前i个字符形成的子串和s2的前j个字符形成的子串能否interleave成s3的前i+j个字符形成的子串，那么就有这样的递推关系：</p>
<ul>
<li>只要 result[i][j - 1] &amp;&amp; s2.charAt(j - 1) == s3.charAt(i + j - 1) 或者 result[i - 1][j] &amp;&amp; s1.charAt(i - 1) == s3.charAt(i + j - 1) 有一个为真，result[i][j]就为真。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span>(String s1, String s2, String s3) {</div><div class="line">        <span class="keyword">if</span> (s3.length() != (s2.length() + s1.length()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">boolean</span> result[][] = <span class="keyword">new</span> <span class="keyword">boolean</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</div><div class="line">        result[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.length(); i++)</div><div class="line">            result[i][<span class="number">0</span>] = result[i - <span class="number">1</span>][<span class="number">0</span>] && (s1.charAt(i - <span class="number">1</span>) == s3.charAt(i - <span class="number">1</span>));</div><div class="line"> </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.length(); j++)</div><div class="line">            result[<span class="number">0</span>][j] = result[<span class="number">0</span>][j - <span class="number">1</span>] && (s2.charAt(j - <span class="number">1</span>) == s3.charAt(j - <span class="number">1</span>));</div><div class="line"> </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.length(); i++) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.length(); j++) {</div><div class="line">                <span class="keyword">boolean</span> r = result[i][j - <span class="number">1</span>] && s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>);</div><div class="line">                result[i][j] = r || (result[i - <span class="number">1</span>][j] && s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>));</div><div class="line">            }</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> result[s1.length()][s2.length()];</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>再看一下这个方法的复杂度，稳定在n的平方。</p>
<h3 id="Insert_Interval"><span id="insert-interval" style="color: #ff0000;">Insert Interval</span></h3>
<p>【题目】Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p>Example 1:<br>Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>
<p>Example 2:<br>Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].</p>
<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>
<p>【解答】循环过程中，分三种情况讨论：</p>
<ul>
<li>newInterval在interval的右侧，把左侧的interval加入list；</li>
<li>newInterval在interval左侧，把左侧的newInterval加入list，把原右侧的interval置为新的newInterval；</li>
<li>newInterval和interval有重叠，这种情况下，构造一个新的newInterval，覆盖范围为原有interval和newInterval的并集。</li>
</ul>
<p>待循环结束，list里面添加余下的尚未处理的那个newInterval（因为它在右侧）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title">insert</span>(ArrayList&lt;Interval&gt; intervals, Interval newInterval) {</div><div class="line">  </div><div class="line">        ArrayList&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</div><div class="line">  </div><div class="line">        <span class="keyword">for</span> (Interval interval : intervals) {</div><div class="line">            <span class="keyword">if</span> (interval.end &lt; newInterval.start) { <span class="comment">// [1,2] _[3,4]_</span></div><div class="line">                res.add(interval);</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (interval.start &gt; newInterval.end) { <span class="comment">// _[1,2]_ [3,4]</span></div><div class="line">                res.add(newInterval);</div><div class="line">                newInterval = interval;</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (interval.end &gt;= newInterval.start || interval.start &lt;= newInterval.end) { <span class="comment">// [1,3] _[2,4]_ or _[1,3]_ [2,4]</span></div><div class="line">                <span class="keyword">int</span> start = Math.min(interval.start, newInterval.start);</div><div class="line">                <span class="keyword">int</span> end = Math.max(newInterval.end, interval.end);</div><div class="line">                 </div><div class="line">                newInterval = <span class="keyword">new</span> Interval(start, end);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// unreachable</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">  </div><div class="line">        res.add(newInterval);</div><div class="line">  </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Wildcard_Matching"><span id="wildcard-matching" style="color: #ff0000;">Wildcard Matching</span></h3>
<p>【题目】Implement wildcard pattern matching with support for ‘?’ and ‘*’.</p>
<pre><code><span class="string">'?'</span> Matches <span class="keyword">any</span> single <span class="keyword">character</span>.
<span class="string">'*'</span> Matches <span class="keyword">any</span> sequence <span class="operator">of</span> <span class="keyword">characters</span> (including <span class="operator">the</span> <span class="constant">empty</span> sequence).

The matching should cover <span class="operator">the</span> entire input <span class="keyword">string</span> (<span class="operator">not</span> partial).

The <span class="function"><span class="keyword">function</span> <span class="title">prototype</span> <span class="title">should</span> <span class="title">be</span>:</span>
bool isMatch(const <span class="keyword">char</span> *s, const <span class="keyword">char</span> *p)

Some examples:
isMatch(<span class="string">"aa"</span>,<span class="string">"a"</span>) → <span class="constant">false</span>
isMatch(<span class="string">"aa"</span>,<span class="string">"aa"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"aaa"</span>,<span class="string">"aa"</span>) → <span class="constant">false</span>
isMatch(<span class="string">"aa"</span>, <span class="string">"*"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"aa"</span>, <span class="string">"a*"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"ab"</span>, <span class="string">"?*"</span>) → <span class="constant">true</span>
isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>) → <span class="constant">false</span>
</code></pre><p>【解答】看到题目以后，第一反应就是通过一个递归函数来解题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span>(String s, String p) {</div><div class="line">        <span class="keyword">return</span> isMatch(s, <span class="number">0</span>, p, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span>(String s, <span class="keyword">int</span> si, String p, <span class="keyword">int</span> pi) {</div><div class="line">        <span class="keyword">if</span> (pi==p.length())</div><div class="line">            <span class="keyword">return</span> si==s.length();</div><div class="line">         </div><div class="line">        <span class="keyword">char</span> cp = p.charAt(pi);</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (si==s.length()) {</div><div class="line">            <span class="keyword">if</span> (cp==<span class="string">'*'</span>)</div><div class="line">                <span class="keyword">return</span> isMatch(s, si, p, pi+<span class="number">1</span>);</div><div class="line">             </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">char</span> cs = s.charAt(si);</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (cp==<span class="string">'*'</span>) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length()-si; i++) {</div><div class="line">                <span class="keyword">if</span> (isMatch(s, si+i, p, pi+<span class="number">1</span>))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">             </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (cp==<span class="string">'?'</span>) {</div><div class="line">            <span class="keyword">return</span> isMatch(s, si+<span class="number">1</span>, p, pi+<span class="number">1</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (cs==cp)</div><div class="line">                <span class="keyword">return</span> isMatch(s, si+<span class="number">1</span>, p, pi+<span class="number">1</span>);</div><div class="line">             </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后，在巨长的case上面执行超时了。于是想了想，除了星号（<em>）以外，其它情况的递归都显然可以免去；而如果遇到星号，要比较星号后面的字符，比如ababccccdddd去匹配</em>d，那么遇到星号以后，要看星号后面那个字符，在这里是d，去源字符串s里面找，如果不是d的话直接忽略掉，如果是d的话继续递归匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span>(String s, String p) {</div><div class="line">        <span class="keyword">return</span> isMatch(s, <span class="number">0</span>, p, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span>(String s, <span class="keyword">int</span> si, String p, <span class="keyword">int</span> pi) {</div><div class="line">        <span class="keyword">while</span> (pi&lt;p.length()) {</div><div class="line">            <span class="keyword">char</span> cp = p.charAt(pi);</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (si==s.length()) {</div><div class="line">                <span class="keyword">if</span> (cp==<span class="string">'*'</span>)</div><div class="line">                    pi++;</div><div class="line">                 </div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">             </div><div class="line">            <span class="keyword">char</span> cs = s.charAt(si);</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (cp==<span class="string">'*'</span>) {</div><div class="line">                pi++;</div><div class="line"> </div><div class="line">                <span class="keyword">int</span> minLen = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</div><div class="line">                    <span class="keyword">if</span> (pi==p.length()) {</div><div class="line">                        <span class="keyword">if</span> (s.length()-si&gt;=minLen)</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                    }</div><div class="line">                     </div><div class="line">                    <span class="keyword">char</span> cp2 = p.charAt(pi);</div><div class="line">                    <span class="keyword">if</span> (cp2==<span class="string">'*'</span>) {</div><div class="line">                        minLen = <span class="number">0</span>;</div><div class="line">                        pi++;</div><div class="line">                    } <span class="keyword">else</span> <span class="keyword">if</span> (cp2==<span class="string">'?'</span>) {</div><div class="line">                        minLen++;</div><div class="line">                        pi++;</div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i=si; i&lt;s.length(); i++) {</div><div class="line">                            <span class="keyword">if</span> (s.charAt(i)==cp2 && i-si&gt;=minLen && isMatch(s, i+<span class="number">1</span>, p, pi+<span class="number">1</span>))</div><div class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                        }</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (cp==<span class="string">'?'</span>) {</div><div class="line">                si++;</div><div class="line">                pi++;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">if</span> (cs==cp) {</div><div class="line">                    si++;</div><div class="line">                    pi++;</div><div class="line">                }</div><div class="line">                 </div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> si==s.length();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可是，遇到某变态case继续超时……于是搞了N久，最后可行的办法是，利用一个标识是否遇到星号的变量（asterisk），以及额外的两个标识在星号之后在s和p出现的指针sa和pa，整个大循环的逻辑是：</p>
<ul>
<li>如果si和pi指向的字符相等，或者pi指向了问号，那么，si++，pi++，这两个是基本指针的前进；</li>
<li>如果pi指向了星号，把pi移到星号之后的那个字符，并且把此时是si存为sa，pi存为pa；</li>
<li>对于余下的情况，考虑在出现过星号的情况，因为两个字符不相等了，那么星号后面那个字符相应的匹配位置需要在s中往后移。</li>
</ul>
<p>注意：在遇到星号的时候要把pi和si分别赋给pa和sa，而在有星号出现后的未匹配事件发生时，要把pa和sa赋回给pi和si（相当于pa和sa占住位置，pi和si往前试探着前行）；另外，循环完毕后，要判断p内还有没有非星号的字符，如果有就匹配失败了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span>(String s, String p) {</div><div class="line">        <span class="keyword">return</span> isMatch(s, <span class="number">0</span>, p, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span>(String s, <span class="keyword">int</span> si, String p, <span class="keyword">int</span> pi) {</div><div class="line">        <span class="keyword">boolean</span> asterisk = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> sa = <span class="number">0</span>, pa = <span class="number">0</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">while</span> (si &lt; s.length()) {</div><div class="line">            <span class="keyword">if</span> (pi == p.length()) {</div><div class="line">                <span class="keyword">if</span> (asterisk) {</div><div class="line">                    sa++;</div><div class="line">                    si = sa;</div><div class="line">                    pi = pa;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line"> </div><div class="line">            <span class="keyword">char</span> cp = p.charAt(pi);</div><div class="line">            <span class="keyword">char</span> cs = s.charAt(si);</div><div class="line"> </div><div class="line">            <span class="keyword">if</span> (cp == <span class="string">'*'</span>) {</div><div class="line">                asterisk = <span class="keyword">true</span>;</div><div class="line"> </div><div class="line">                pi++;</div><div class="line">                pa = pi;</div><div class="line">                sa = si;</div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (cp == <span class="string">'?'</span>) {</div><div class="line">                si++;</div><div class="line">                pi++;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">if</span> (cs == cp) {</div><div class="line">                    si++;</div><div class="line">                    pi++;</div><div class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (asterisk) {</div><div class="line">                    pi = pa;</div><div class="line">                    sa++;</div><div class="line">                    si = sa;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pi; i &lt; p.length(); i++) {</div><div class="line">            <span class="keyword">if</span> (p.charAt(i) != <span class="string">'*'</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Distinct_Subsequences"><span id="distinct-subsequences" style="color: #ff0000;">Distinct Subsequences</span></h3>
<p>【题目】Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p>
<p>Here is an example:<br>S = <code>&quot;rabbbit&quot;</code>, T = <code>&quot;rabbit&quot;</code></p>
<p>Return <code>3</code>.<br>【解答】拿到这样的题目，首先，回溯法遍历所有情况肯定是可以做的，但是那样复杂度太高。为了减小复杂度，很容易考虑到使用动态规划。但是动态规划怎么设计递推关系就很重要了：</p>
<ul>
<li>考虑到S.length()&gt;=T.length()，那么其中一种递推关系是，假设f(i)表示S的[0,i)子串和T形成的distinct子串数量，那么如果可以找到f(i+1)和f(i)之间的递推关系就好解了，这是其中一个思路，写出来的DP是一维的；</li>
<li>也可以假设f(i,j)表示的是S的[0,i)子串和T的[0,j)子串，需要寻找f(i,j)和f(i-1,j)、f(i,j-1)、f(i-1,j-1)这样的递推关系，我采用的是这一条思路：</li>
<li>如果S[i]==T[j]，那么当S[i]没出现在T里面的时候，f(i,j)=f(i-1,j)，当S[i]出现在T里面，就有f(i,j)=f(i-1,j-1)，因此，这种情况下f(i,j) = f(i-1,j) + f(i-1,j-1)；</li>
<li>如果S[i]!=T[j]，那么显然S[i]不能出现在T里面，于是f(i,j) = f(i-1,j)。</li>
</ul>
<p>注意程序出口，当j为0，即T变成了空串，序列数就是1；反过来，当S为空串的时候，T一定是空串，否则T的长度大于S的长度了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span>(String S, String T) {</div><div class="line">        Integer[][] cache = <span class="keyword">new</span> Integer[S.length()+<span class="number">1</span>][T.length()+<span class="number">1</span>];</div><div class="line">        <span class="keyword">return</span> numDistinct(S, T, S.length(), T.length(), cache);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">numDistinct</span>(String S, String T, <span class="keyword">int</span> i, <span class="keyword">int</span> j, Integer[][] cache) {</div><div class="line">        <span class="keyword">if</span> (cache[i][j]!=<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> cache[i][j];</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span>) {</div><div class="line">            <span class="keyword">char</span> sc = S.charAt(i-<span class="number">1</span>);</div><div class="line">            <span class="keyword">char</span> st = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (j&gt;<span class="number">0</span>)</div><div class="line">                st = T.charAt(j-<span class="number">1</span>);</div><div class="line">             </div><div class="line">            <span class="keyword">int</span> prev = numDistinct(S, T, i-<span class="number">1</span>, j, cache);</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (sc!=st || j==<span class="number">0</span>) {</div><div class="line">                cache[i][j] = prev;</div><div class="line">                <span class="keyword">return</span> prev;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">int</span> total = prev + numDistinct(S, T, i-<span class="number">1</span>, j-<span class="number">1</span>, cache);</div><div class="line">                cache[i][j] = total;</div><div class="line">                <span class="keyword">return</span> total;</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (j==<span class="number">0</span>) {</div><div class="line">                cache[i][j] = <span class="number">1</span>;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                cache[i][j] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可是上的解法在某变态case的时候出现了StackOverflowError，通常这种情况下，如果你的编程语言支持尾递归，那可以考虑把它优化成尾递归的形式，如果不支持（比如Java），那就干脆尝试把它写成循环（其实下面的代码还是显得啰嗦，还可以继续优化，我留着这样是因为在思考过程中把所有分支情况全部写出来了，是最原始的分类讨论的体现，我觉得看起来直白；而且，空间复杂度上面，是可以从n平方降到n的，因为i是一直在增大，之前的数据没有必要保留，每次这个数组保存的都是当前i的迭代数据）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span>(String S, String T) {</div><div class="line">        <span class="keyword">if</span> (T.length()==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (S.length()==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[S.length()][T.length()];</div><div class="line"> </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;S.length(); i++) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i && j&lt;T.length(); j++) {</div><div class="line">                <span class="keyword">if</span> (S.charAt(i)!=T.charAt(j)) {</div><div class="line">                    <span class="keyword">if</span> (i&gt;j) { <span class="comment">// i!=0</span></div><div class="line">                        cache[i][j] = cache[i-<span class="number">1</span>][j];</div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        cache[i][j] = <span class="number">0</span>;</div><div class="line">                    }</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="keyword">if</span> (i&gt;j) {</div><div class="line">                        <span class="keyword">if</span> (j==<span class="number">0</span>)</div><div class="line">                            cache[i][j] = cache[i-<span class="number">1</span>][j] + <span class="number">1</span>;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            cache[i][j] = cache[i-<span class="number">1</span>][j] + cache[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        <span class="keyword">if</span> (i==<span class="number">0</span>)</div><div class="line">                            cache[i][j] = <span class="number">1</span>;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            cache[i][j] = cache[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> cache[S.length()-<span class="number">1</span>][T.length()-<span class="number">1</span>];</div><div class="line">    } </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Word_Break_II"><span id="word-break-ii" style="color: #ff0000;">Word Break II</span></h3>
<p>【题目】Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.</p>
<p>Return all such possible sentences.</p>
<p>For example, given<br>s = <code>&quot;catsanddog&quot;</code>,<br>dict = <code>[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</code>.</p>
<p>A solution is <code>[&quot;cats and dog&quot;, &quot;cat sand dog&quot;]</code>.</p>
<p>【解答】动态规划求解。判断给定字符串是否以某单词结尾，如果是，就抠掉该结尾单词，余下子串继续递归判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span>(String s, Set&lt;String&gt; dict) {</div><div class="line">        Map&lt;Integer, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;String&gt;&gt;();</div><div class="line">        List&lt;String&gt; defaultList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        defaultList.add(<span class="string">""</span>);</div><div class="line">        map.put(-<span class="number">1</span>, defaultList);</div><div class="line">        <span class="keyword">return</span> getAllPossibleSentences(s, dict, s.length()-<span class="number">1</span>, map);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title">getAllPossibleSentences</span>(String s, Set&lt;String&gt; dict, <span class="keyword">int</span> pos, Map&lt;Integer, List&lt;String&gt;&gt; map){</div><div class="line">        <span class="keyword">if</span> (map.containsKey(pos))</div><div class="line">            <span class="keyword">return</span> map.get(pos);</div><div class="line">         </div><div class="line">        String sub = s.substring(<span class="number">0</span>, pos+<span class="number">1</span>);</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (String word : dict) {</div><div class="line">            <span class="keyword">if</span> (sub.endsWith(word)) {</div><div class="line">                <span class="keyword">int</span> firstSegEnd = pos - word.length();</div><div class="line">                <span class="keyword">if</span> (firstSegEnd&lt;-<span class="number">1</span>) <span class="comment">// no solution found</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                 </div><div class="line">                List&lt;String&gt; subList = getAllPossibleSentences(s, dict, firstSegEnd, map);</div><div class="line">                <span class="keyword">for</span> (String str : subList) {</div><div class="line">                    <span class="keyword">if</span> (<span class="string">""</span>.equals(str))</div><div class="line">                        list.add(word);</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        list.add(str + <span class="string">" "</span> + word);</div><div class="line">                }</div><div class="line">            } <span class="comment">// if</span></div><div class="line">        }<span class="comment">// for</span></div><div class="line">         </div><div class="line">        map.put(pos, list)</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="First_Missing_Positive"><span id="first-missing-positive" style="color: #ff0000;">First Missing Positive</span></h3>
<p>【题目】Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br>Given <code>[1,2,0]</code> return 3,<br>and <code>[3,4,-1,1]</code> return 2.</p>
<p>Your algorithm should run in O(n) time and uses constant space.</p>
<p>【解答】我开始只注意到了O(n)的时间复杂度，于是引入一个HashSet，把所有数往里一放，最后再从1开始累加，并挨个检查在set里面有没有，要没有就说明找到那个数了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span>(<span class="keyword">int</span>[] A) {</div><div class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">         </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A)</div><div class="line">            set.add(a);</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i&lt;=A.length) {</div><div class="line">            <span class="keyword">if</span> (!set.contains(i))</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">             </div><div class="line">            i++;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是后来看到题目要求常量的额外空间，那我的这个办法其实是错误的。要记录下这些数，又要常量复杂度，只能考虑能不能重用入参数组A了，按理说修改参数里面的东西是不会引入空间复杂度的。</p>
<p>对于数组A，如果所有的A[i]==i+1的话，那么说明这些数正好是从1开始的连续正整数序列，但是现在有可能有0，有负数，而正数序列也可能有重复，有断开的地方……但无论怎样，遍历一遍A，用交换的办法尽可能把每个数都放到该放的地方去，当然，只有大小不超过A长度的正整数才能够找到安居之所。即，把A[i]放到A[A[i]-1]去。这一遍遍历之后，从头开始数，第一个数值和下标对不上（即A[i]!=i+1）的那个元素的下标，就是要求的missing positive。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span>(<span class="keyword">int</span>[] A) {</div><div class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">         </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A)</div><div class="line">            set.add(a);</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i&lt;=A.length) {</div><div class="line">            <span class="keyword">if</span> (!set.contains(i))</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">             </div><div class="line">            i++;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>虽说AC了，但是粗看我对其中的时间复杂度是否为n阶并不确定，看着一个for和一个while嵌套的。于是我改成了这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span>(<span class="keyword">int</span>[] A) {</div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i&lt;A.length) {</div><div class="line">            <span class="keyword">if</span> (A[i]!=(i+<span class="number">1</span>) && A[i]&gt;=<span class="number">1</span> && A[i]&lt;=A.length && A[A[i]-<span class="number">1</span>]!=A[i]) {</div><div class="line">                <span class="comment">// swap</span></div><div class="line">                <span class="keyword">int</span> temp = A[i];</div><div class="line">                A[i] = A[temp-<span class="number">1</span>];</div><div class="line">                A[temp-<span class="number">1</span>] = temp;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                i++;</div><div class="line">            }</div><div class="line">        }</div><div class="line">     </div><div class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;A.length; i++) {</div><div class="line">            <span class="keyword">if</span> (A[i]!=i+<span class="number">1</span>)</div><div class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> A.length+<span class="number">1</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>看着是少了一层嵌套循环，但是其实呢，做法上面换汤不换药，在每次swap发生的时候，i是不前进的，也就是说，对于A[i]，swap一次，把A[i]换到该去的地方去了，但是换过来一个别的数，而这个新数因为在A[i]上，要继续swap……直到条件不满足，没有继续swap的必要，i才继续前进。但是仔细分析，由于每个到来到A[i]的数都去了它应该去的地方，A[i]去了新地方以后便不会再被换走，因而复杂度确实为n。不管是写成上面那种形式还是这种形式。</p>
<p>这道题还是有些有趣的。</p>
<h3 id="Word_Ladder_II"><span id="word-ladder-ii" style="color: #ff0000;">Word Ladder II</span></h3>
<p>【题目】Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:</p>
<p>Only one letter can be changed at a time<br>Each intermediate word must exist in the dictionary<br>For example,</p>
<p>Given:<br>start = <code>&quot;hit&quot;</code><br>end = <code>&quot;cog&quot;</code><br>dict = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code></p>
<p>Return</p>
<pre><code>  [
    [<span class="string">"hit"</span>,<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"cog"</span>],
    [<span class="string">"hit"</span>,<span class="string">"hot"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]
  ]
</code></pre><p>Note:</p>
<ul>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
</ul>
<p>【解答】这道题刚拿到手的时候觉得挺简单的，BFS。每一层都去dict里面寻找所有的单词，如果二者只差一个字母（isNeighbor），就找到结果了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title">findLadders</span>(String start, String end, Set&lt;String&gt; dict) {</div><div class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;String&gt; ll = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        ll.add(start);</div><div class="line">        list.add(ll);</div><div class="line">        dict.remove(start);</div><div class="line">         </div><div class="line">        <span class="keyword">while</span> (!dict.isEmpty()) {</div><div class="line">            Set&lt;String&gt; toRemove = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">            List&lt;List&lt;String&gt;&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            List&lt;List&lt;String&gt;&gt; matched = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">             </div><div class="line">            <span class="keyword">for</span> (List&lt;String&gt; l : list) {</div><div class="line">                String from = l.get(l.size()-<span class="number">1</span>);</div><div class="line">                <span class="keyword">for</span> (String d : dict) {</div><div class="line">                    <span class="keyword">if</span> (isNeighbor(from, d)) {</div><div class="line">                        toRemove.add(d);</div><div class="line">                         </div><div class="line">                        List&lt;String&gt; nl = <span class="keyword">new</span> ArrayList&lt;&gt;(l);</div><div class="line">                        nl.add(d);</div><div class="line"> </div><div class="line">                        <span class="keyword">if</span> (d.equals(end))</div><div class="line">                            matched.add(nl);</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            newList.add(nl);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (!matched.isEmpty())</div><div class="line">                <span class="keyword">return</span> matched;</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (toRemove.isEmpty())</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</div><div class="line">             </div><div class="line">            dict.removeAll(toRemove);</div><div class="line">            list = newList;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNeighbor</span>(String s1, String s2) {</div><div class="line">        <span class="keyword">boolean</span> dif = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.length(); i++) {</div><div class="line">            <span class="keyword">char</span> c1 = s1.charAt(i);</div><div class="line">            <span class="keyword">char</span> c2 = s2.charAt(i);</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (c1!=c2) {</div><div class="line">                <span class="keyword">if</span> (!dif)</div><div class="line">                    dif = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是很快遇到某case就超时了。于是调整一下角度，对每次待匹配的单词，不是去dict里面匹配，而是根据该单词的每个字母，都可以变化成任意一个其它字母的规则，因为那样每次都形成一个新单词，再拿这个新单词到dict里面去寻找是否有匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title">findLadders</span>(String start, String end, Set&lt;String&gt; dict) {</div><div class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;String&gt; ll = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        ll.add(start);</div><div class="line">        list.add(ll);</div><div class="line">        dict.remove(start);</div><div class="line">         </div><div class="line">        <span class="keyword">while</span> (!dict.isEmpty()) {</div><div class="line">            Set&lt;String&gt; toRemove = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">            List&lt;List&lt;String&gt;&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            List&lt;List&lt;String&gt;&gt; matched = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">             </div><div class="line">            <span class="keyword">for</span> (List&lt;String&gt; l : list) {</div><div class="line">                String from = l.get(l.size()-<span class="number">1</span>);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;from.length(); i++) {</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> ch=<span class="string">'a'</span>; ch&lt;=<span class="string">'z'</span>; ch++) {</div><div class="line">                        <span class="keyword">char</span>[] cs = from.toCharArray();</div><div class="line">                        <span class="keyword">if</span> (cs[i]!=ch)</div><div class="line">                            cs[i] = ch;</div><div class="line">                        String ns = <span class="keyword">new</span> String(cs);</div><div class="line">                         </div><div class="line">                        <span class="keyword">if</span> (dict.contains(ns)) {</div><div class="line">                            toRemove.add(ns);</div><div class="line">                             </div><div class="line">                            List&lt;String&gt; nl = <span class="keyword">new</span> ArrayList&lt;&gt;(l);</div><div class="line">                            nl.add(ns);</div><div class="line">                             </div><div class="line">                            <span class="keyword">if</span> (ns.equals(end))</div><div class="line">                                matched.add(nl);</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                newList.add(nl);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (!matched.isEmpty())</div><div class="line">                <span class="keyword">return</span> matched;</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (toRemove.isEmpty())</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</div><div class="line">             </div><div class="line">            dict.removeAll(toRemove);</div><div class="line">            list = newList;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>结果出现了Memory Limit Exceeded。怎么办呢？忽然想到了对于这种搜索的改进，从start开始的单向搜索可以优化成从start和end两头一起往中间搜索这样的双向搜索形式，理论上可以减少BSF最宽一层的节点数量（代码看起来有点长，但是其实逻辑并不复杂）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title">findLadders</span>(String start, String end, Set&lt;String&gt; dict) {</div><div class="line">        <span class="comment">// forward list</span></div><div class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;String&gt; ll = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        ll.add(start);</div><div class="line">        list.add(ll);</div><div class="line">        dict.remove(start);</div><div class="line">         </div><div class="line">        <span class="comment">// backward list</span></div><div class="line">        List&lt;List&lt;String&gt;&gt; backList = <span class="keyword">null</span>;</div><div class="line">         </div><div class="line">        List&lt;List&lt;String&gt;&gt; matched = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">         </div><div class="line">        <span class="keyword">while</span> (!dict.isEmpty()) {</div><div class="line">            <span class="comment">// 1. forward bfs</span></div><div class="line">            Set&lt;String&gt; toRemove = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">            List&lt;List&lt;String&gt;&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">             </div><div class="line">            <span class="keyword">for</span> (List&lt;String&gt; l : list) {</div><div class="line">                String from = l.get(l.size()-<span class="number">1</span>);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;from.length(); i++) {</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> ch=<span class="string">'a'</span>; ch&lt;=<span class="string">'z'</span>; ch++) {</div><div class="line">                        <span class="keyword">char</span>[] cs = from.toCharArray();</div><div class="line">                        <span class="keyword">if</span> (cs[i]!=ch)</div><div class="line">                            cs[i] = ch;</div><div class="line">                        String ns = <span class="keyword">new</span> String(cs);</div><div class="line">                         </div><div class="line">                        <span class="keyword">if</span> (dict.contains(ns)) {</div><div class="line">                            toRemove.add(ns);</div><div class="line">                             </div><div class="line">                            List&lt;String&gt; nl = <span class="keyword">new</span> ArrayList&lt;&gt;(l);</div><div class="line">                            nl.add(ns);</div><div class="line">                             </div><div class="line">                            <span class="keyword">if</span> (ns.equals(end))</div><div class="line">                                matched.add(nl);</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                newList.add(nl);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (!matched.isEmpty() || toRemove.isEmpty())</div><div class="line">                <span class="keyword">return</span> matched;</div><div class="line">             </div><div class="line">            dict.removeAll(toRemove);</div><div class="line">            list = newList;</div><div class="line">             </div><div class="line">            <span class="comment">// 2. backward bfs</span></div><div class="line">            <span class="keyword">if</span> (backList==<span class="keyword">null</span>) {</div><div class="line">                backList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">                ll = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">                ll.add(end);</div><div class="line">                backList.add(ll);</div><div class="line">                dict.remove(end);</div><div class="line">            }</div><div class="line">             </div><div class="line">            newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            toRemove.clear();</div><div class="line">             </div><div class="line">            <span class="keyword">for</span> (List&lt;String&gt; bl : backList) {</div><div class="line">                String b = bl.get(<span class="number">0</span>);</div><div class="line">                <span class="keyword">for</span> (String s : dict) {</div><div class="line">                    <span class="keyword">if</span> (isNeighbor(b, s)) {</div><div class="line">                        toRemove.add(s);</div><div class="line">                         </div><div class="line">                        List&lt;String&gt; nl = <span class="keyword">new</span> ArrayList&lt;&gt;(bl);</div><div class="line">                        nl.add(<span class="number">0</span>, s);</div><div class="line">                         </div><div class="line">                        newList.add(nl);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (toRemove.isEmpty())</div><div class="line">                <span class="keyword">return</span> matched;</div><div class="line">                 </div><div class="line">            dict.removeAll(toRemove);</div><div class="line">            backList = newList;</div><div class="line">             </div><div class="line">            <span class="comment">// 3. match</span></div><div class="line">            <span class="keyword">for</span> (List&lt;String&gt; l : list) {</div><div class="line">                <span class="keyword">for</span> (List&lt;String&gt; bl : backList) {</div><div class="line">                    String s1 = l.get(l.size()-<span class="number">1</span>);</div><div class="line">                    String s2 = bl.get(<span class="number">0</span>);</div><div class="line">                     </div><div class="line">                    <span class="keyword">if</span> (isNeighbor(s1, s2)) {</div><div class="line">                        List&lt;String&gt; nl = <span class="keyword">new</span> ArrayList&lt;&gt;(l);</div><div class="line">                        nl.addAll(bl);</div><div class="line">                         </div><div class="line">                        matched.add(nl);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (!matched.isEmpty())</div><div class="line">                <span class="keyword">return</span> matched;</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNeighbor</span>(String s1, String s2) {</div><div class="line">        <span class="keyword">boolean</span> dif = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.length(); i++) {</div><div class="line">            <span class="keyword">char</span> c1 = s1.charAt(i);</div><div class="line">            <span class="keyword">char</span> c2 = s2.charAt(i);</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (c1!=c2) {</div><div class="line">                <span class="keyword">if</span> (!dif)</div><div class="line">                    dif = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>代码真是复杂不少，遗憾的是，继续Memory Limit Exceeded，服了，这条路看来是走不通了。从网上搜索，有各种解法，都挺复杂的。下面列出的这个方法是从这个博客上面摘录下来的，属于思路上相对比较清晰的做法了。整个过程拆成两步，BFS来构造表示单词变化关系的树，DFS来最后搜索路径。从宏观的复杂度上看，比我最原始的做法节约就节约在对路径list的遍历上面，我的做法因为要遍历路径的list，导致循环嵌套多了一层，但是这里使用一个map存放每个节点和下一层的对应关系，省下了这层循环，当然，最后需要额外的DFS来构造这个list。虽说如此，我还是觉得方法不够优雅简洁，如果你有清晰简洁的方法，请告诉我。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    class WordWithLevel {</div><div class="line">        String word;</div><div class="line">        <span class="keyword">int</span> level;</div><div class="line"> </div><div class="line">        <span class="keyword">public</span> <span class="title">WordWithLevel</span>(String word, <span class="keyword">int</span> level) {</div><div class="line">            <span class="keyword">this</span>.word = word;</div><div class="line">            <span class="keyword">this</span>.level = level;</div><div class="line">        }</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> String end;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;String&gt;&gt; result;</div><div class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; nextMap;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;String&gt;&gt; <span class="title">findLadders</span>(String start, String end,</div><div class="line">            HashSet&lt;String&gt; dict) {</div><div class="line">        result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;String&gt;&gt;();</div><div class="line">        <span class="keyword">this</span>.end = end;</div><div class="line"> </div><div class="line">        <span class="comment">// unvisited words set</span></div><div class="line">        Set&lt;String&gt; unVisited = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        unVisited.addAll(dict);</div><div class="line">        unVisited.add(start);</div><div class="line">        unVisited.remove(end);</div><div class="line"> </div><div class="line">        <span class="comment">// used to record the map info of &lt;word : the words of next level&gt;</span></div><div class="line">        nextMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</div><div class="line">        <span class="keyword">for</span> (String e : unVisited) {</div><div class="line">            nextMap.put(e, <span class="keyword">new</span> ArrayList&lt;String&gt;());</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="comment">// BFS to search from the end to start</span></div><div class="line">        Queue&lt;WordWithLevel&gt; queue = <span class="keyword">new</span> LinkedList&lt;WordWithLevel&gt;();</div><div class="line">        queue.add(<span class="keyword">new</span> WordWithLevel(end, <span class="number">0</span>));</div><div class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> finalLevel = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> currentLevel = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> preLevel = <span class="number">0</span>;</div><div class="line">        Set&lt;String&gt; visitedWordsInThisLevel = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</div><div class="line">            WordWithLevel wordWithLevel = queue.poll();</div><div class="line">            String word = wordWithLevel.word;</div><div class="line">            currentLevel = wordWithLevel.level;</div><div class="line">            <span class="keyword">if</span> (found && currentLevel &gt; finalLevel) {</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (currentLevel &gt; preLevel) {</div><div class="line">                unVisited.removeAll(visitedWordsInThisLevel);</div><div class="line">            }</div><div class="line">            preLevel = currentLevel;</div><div class="line">            <span class="keyword">char</span>[] wordCharArray = word.toCharArray();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); ++i) {</div><div class="line">                <span class="keyword">char</span> originalChar = wordCharArray[i];</div><div class="line">                <span class="keyword">boolean</span> foundInThisCycle = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; ++c) {</div><div class="line">                    wordCharArray[i] = c;</div><div class="line">                    String newWord = <span class="keyword">new</span> String(wordCharArray);</div><div class="line">                    <span class="keyword">if</span> (c != originalChar && unVisited.contains(newWord)) {</div><div class="line">                        nextMap.get(newWord).add(word);</div><div class="line">                        <span class="keyword">if</span> (newWord.equals(start)) {</div><div class="line">                            found = <span class="keyword">true</span>;</div><div class="line">                            finalLevel = currentLevel;</div><div class="line">                            foundInThisCycle = <span class="keyword">true</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        }</div><div class="line">                        <span class="keyword">if</span> (visitedWordsInThisLevel.add(newWord)) {</div><div class="line">                            queue.add(<span class="keyword">new</span> WordWithLevel(newWord,</div><div class="line">                                    currentLevel + <span class="number">1</span>));</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (foundInThisCycle) {</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                wordCharArray[i] = originalChar;</div><div class="line">            }</div><div class="line">        }</div><div class="line"> </div><div class="line">        <span class="keyword">if</span> (found) {</div><div class="line">            <span class="comment">// dfs to get the paths</span></div><div class="line">            ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">            list.add(start);</div><div class="line">            getPaths(start, list, finalLevel + <span class="number">1</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPaths</span>(String currentWord, ArrayList&lt;String&gt; list, <span class="keyword">int</span> level) {</div><div class="line">        <span class="keyword">if</span> (currentWord.equals(end)) {</div><div class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(list));</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (level &gt; <span class="number">0</span>) {</div><div class="line">            List&lt;String&gt; parentsSet = nextMap.get(currentWord);</div><div class="line">            <span class="keyword">for</span> (String parent : parentsSet) {</div><div class="line">                list.add(parent);</div><div class="line">                getPaths(parent, list, level - <span class="number">1</span>);</div><div class="line">                list.remove(list.size() - <span class="number">1</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Find_Minimum_in_Rotated_Sorted_Array_II"><span id="find-minimum-in-rotated-sorted-array-ii" style="color: #ff0000;">Find Minimum in Rotated Sorted Array II</span></h3>
<p>【题目】Follow up for “Find Minimum in Rotated Sorted Array”:<br>What if duplicates are allowed? Would this affect the run-time complexity? How and why?</p>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code>might become<code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<p>【解答】解这个题目，先简化一下条件，不考虑duplicates存在的情况，那么任意两个元素都不相等，通过比对num[left]、num[mid]和num[right]会得出三种可能的大小关系组合，用具体例子来说就是：</p>
<ul>
<li>num[left]</li>
<li>num[left]num[right]，比如3 4 5 1 2；</li>
<li>num[left]&gt;num[mid] &amp;&amp; num[mid]</li>
</ul>
<p>在这之后，再考虑存在duplicates的情况。这样就不容易遗留可能性。另外，需要注意两个特殊情况：</p>
<ul>
<li>一种最特殊的情况是num[left]、num[mid]和num[right]三者全部相等，这个时候就完全不知道这个pivot到底在左半支还是右半支，这时候只能left右移并right左移，一点一点缩小范围。所以最坏情况下时间复杂度是n。</li>
<li>还有一个要注意的是，当left和right只相差1的时候，mid==left，如果再走到left=mid赋值的分支里面，就会死循环，为了避免这种情况发生，需要处理好这种情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span>(<span class="keyword">int</span>[] num) {</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> right = num.length-<span class="number">1</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">while</span> (left&lt;right-<span class="number">1</span>) {</div><div class="line">            <span class="keyword">int</span> mid = (right+left)/<span class="number">2</span>;</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (num[left]num[mid]) {</div><div class="line">                    <span class="keyword">return</span> num[left];</div><div class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (num[right]num[mid]) { <span class="comment">// 4 5 1 2 3</span></div><div class="line">                <span class="keyword">if</span> (num[mid]num[right]) {</div><div class="line">                    <span class="comment">// impossible</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Impossible..."</span>);</div><div class="line">                } <span class="keyword">else</span> { <span class="comment">// num[mid]==num[right]</span></div><div class="line">                    right = mid;</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">if</span> (num[right]==num[mid]) {</div><div class="line">                    left++;</div><div class="line">                    right--;</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    left = mid;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> Math.min(num[left], num[right]);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Regular_Expression_Matching"><span id="regular-expression-matching" style="color: #ff0000;">Regular Expression Matching</span></h3>
<p>【题目】Implement regular expression matching with support for ‘.’ and ‘<em>‘.<br>    ‘.’ Matches any single character.<br>    ‘</em>‘ Matches zero or more of the preceding element.</p>
<pre><code>The matching should cover the entire input <span class="built_in">string</span> (<span class="keyword">not</span> <span class="keyword">partial</span>).

The <span class="keyword">function</span> prototype should be:
bool isMatch(<span class="keyword">const</span> <span class="built_in">char</span> *s, <span class="keyword">const</span> <span class="built_in">char</span> *p)

Some examples:
isMatch(<span class="string">"aa"</span>,<span class="string">"a"</span>) → <span class="literal">false</span>
isMatch(<span class="string">"aa"</span>,<span class="string">"aa"</span>) → <span class="literal">true</span>
isMatch(<span class="string">"aaa"</span>,<span class="string">"aa"</span>) → <span class="literal">false</span>
isMatch(<span class="string">"aa"</span>, <span class="string">"a*"</span>) → <span class="literal">true</span>
isMatch(<span class="string">"aa"</span>, <span class="string">".*"</span>) → <span class="literal">true</span>
isMatch(<span class="string">"ab"</span>, <span class="string">".*"</span>) → <span class="literal">true</span>
isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>) → <span class="literal">true</span>
</code></pre><p>【解答】点号和星号的含义和正则表达式一致。注意”abc”.matches(“.<em>“)是返回true的，换言之，”.</em>“可以代表任何字符串，空串也可以。我原来的做法是尝试使用在DP中分类讨论的办法，包括分成”a”、”.a”、”a<em>“、”.</em>”这几种情况分别处理，代码写得冗长，做到一半自己都搞晕了。本来想继续沿着DP的思路走下去，但是看到下面的这个做法（来自于<a href="http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/" target="_blank" rel="external">这里</a>）以后，我觉得我原来的思路太弱了。下面这个做法是我目前看到的解法最简洁漂亮的代码，整个过程也不需要用额外的空间来存储重复计算的结果。思路是，把各种情况分成这样两种：</p>
<ul>
<li>p的第二个字符（p[1]）不是星号，在这种情况下，如果第一个字符p[0]是星号，或者p[0]==s[0]，那就可以继续递归匹配余下的子串，否则返回匹配失败；</li>
<li>p的第二个字符（p[1]）是星号，在这种情况下，通过一个i来表示”.<em>“或者”a</em>“管住的那段S子串的结束位置（即s中的子串[0,i]），i之后的子串和p去掉开头的这个”.<em>“或者”a</em>“后余下的子串继续参与后续的匹配，匹配上了皆大欢喜，匹配不上则令i前进。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span>(String s, String p) {</div><div class="line">        <span class="keyword">if</span> (p.length() == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> s.length() == <span class="number">0</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">if</span> (p.length() == <span class="number">1</span> || p.charAt(<span class="number">1</span>) != <span class="string">'*'</span>) {</div><div class="line">            <span class="comment">// empty s or unmatch</span></div><div class="line">            <span class="keyword">if</span> (s.length() &lt; <span class="number">1</span> || (p.charAt(<span class="number">0</span>) != <span class="string">'.'</span> && s.charAt(<span class="number">0</span>) != p.charAt(<span class="number">0</span>)))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">             </div><div class="line">            <span class="keyword">return</span> isMatch(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">int</span> i = -<span class="number">1</span>;</div><div class="line">            <span class="comment">// match</span></div><div class="line">            <span class="keyword">while</span> (i &lt; s.length() && (i &lt; <span class="number">0</span> || p.charAt(<span class="number">0</span>) == <span class="string">'.'</span> || p.charAt(<span class="number">0</span>) == s.charAt(i))) {</div><div class="line">                <span class="keyword">if</span> (isMatch(s.substring(i + <span class="number">1</span>), p.substring(<span class="number">2</span>)))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                i++;</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>


      
    </div>
    <footer>
      

        
          <div class="alignleft post-nav">
            <em>上一篇: </em><a href="/2012/03/23/java-oop/">面向对象的SOLID原则与Java类库框架设计哲学</a>
          </div>
        
        
          <div class="alignright post-nav">
            <em>下一篇: </em><a href="/2012/03/10/leetcode-database/">LeetCode数据库题目解答</a>
          </div>
          <div class="clearfix"></div>
        

        
          <div class="copyright">
            
              <span class="claim">版权声明：自由转载-非商用-无演绎-保持署名 @ Lawrence-zxc</span>
            
            
              <span class="from-link">
                <em>本文链接地址:</em>
                <a href="/2012/03/11/leetcode/">
                  http://lawrence-zxc.github.io/2012/03/11/leetcode/
                </a>
              </span>
            
          </div>
        
        
  
  <div class="categories">
    <a href="/categories/日志/">日志</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/LeetCode/">LeetCode</a>, <a href="/tags/Java/">Java</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_sinaweibo_like"></a>
    
    
      <a class="addthis_button_linkedin"></a>
    
    
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <!--<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>-->

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<nav id="pagination" >
    
    <a href="/2012/03/23/java-oop/" class="alignleft prev" >上一页</a>
    
    
    <a href="/2012/03/10/leetcode-database/" class="alignright next" >下一页</a>
    
    <div class="clearfix"></div>
</nav>

<section id="comment">
    <h1 class="title">留言</h1>
    <div id="disqus_thread">
    	<noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="2012/03/11/leetcode/" data-title="LeetCode题目解答,Java实现(Hard部分)" data-url="http://lawrence-zxc.github.io/2012/03/11/leetcode/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"zxc337"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</section>


</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="text" name="q" results="0" placeholder="搜一下">
    <i class="icon-search"></i>
    <input type="hidden" name="q" value="site:lawrence-zxc.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Git/">Git</a><small>2</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>27</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>4</small></li>
  
    <li><a href="/tags/LeetCode/">LeetCode</a><small>2</small></li>
  
    <li><a href="/tags/Linux/">Linux</a><small>21</small></li>
  
    <li><a href="/tags/Mac-Unix/">Mac/Unix</a><small>1</small></li>
  
    <li><a href="/tags/Maven/">Maven</a><small>2</small></li>
  
    <li><a href="/tags/Mysql/">Mysql</a><small>2</small></li>
  
    <li><a href="/tags/Nginx/">Nginx</a><small>5</small></li>
  
    <li><a href="/tags/Oracle/">Oracle</a><small>4</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>3</small></li>
  
    <li><a href="/tags/XMPP/">XMPP</a><small>2</small></li>
  
    <li><a href="/tags/其他/">其他</a><small>0</small></li>
  
    <li><a href="/tags/开始/">开始</a><small>3</small></li>
  
    <li><a href="/tags/技术/">技术</a><small>1</small></li>
  
    <li><a href="/tags/旅行/">旅行</a><small>1</small></li>
  
    <li><a href="/tags/架构/">架构</a><small>3</small></li>
  
    <li><a href="/tags/生活/">生活</a><small>1</small></li>
  
    <li><a href="/tags/读书/">读书</a><small>0</small></li>
  
    <li><a href="/tags/随感/">随感</a><small>7</small></li>
  
  </ul>
</div>


  <div class="trace-invest">
    <span>
        <a href="https://github.com/Lawrence-zxc" target="_blank">欢迎光临我的技术Blog网站 </br>Fork me on Github</a>
    </span>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2015/04/04/jishu-hehuoren/">技术合伙人为什么喜欢谈钱胜过情怀？</a>
      </li>
    
      <li>
        <a href="/2015/04/01/reverse-o2o/">分享一个用户自发需求的反向O2O设想</a>
      </li>
    
      <li>
        <a href="/2015/03/08/shujiawang/">面向企业和个人O2O图书租赁服务设想</a>
      </li>
    
      <li>
        <a href="/2015/03/05/pingjiaapp/">关于电商商品评价评论独立第三方平台构想</a>
      </li>
    
      <li>
        <a href="/2015/01/23/suishoupai/">关于随手拍图片人脸识别APP需求的想法</a>
      </li>
    
      <li>
        <a href="/2014/11/25/xushen/">徐神的诗</a>
      </li>
    
      <li>
        <a href="/2014/11/20/openfire/">Openfire服务端错误解决</a>
      </li>
    
      <li>
        <a href="/2014/11/16/xmpp/">xmpp通信过程分析</a>
      </li>
    
      <li>
        <a href="/2014/11/10/oracle-index/">Oracle大批量高效地更新大数据表索引字段</a>
      </li>
    
      <li>
        <a href="/2014/11/10/oracle-partition/">Oracle Partition Common Usage</a>
      </li>
    
      <li>
        <a href="/2014/10/28/jvm-strace/">jvm退出的原因,使用strace定位</a>
      </li>
    
      <li>
        <a href="/2014/10/28/load-balancing/">负载均衡和过载保护</a>
      </li>
    
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <div id="go-pg-top"><i class="icon-arrow-up"></i></div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 Jeck Zhang
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/page.js"></script>


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a5eb19e532c0b101d72226b1325e6a78";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</body>

</html>